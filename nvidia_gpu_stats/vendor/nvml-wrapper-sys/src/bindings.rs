/* automatically generated by rust-bindgen 0.68.1 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use std::os::raw;

pub const NVML_API_VERSION: u32 = 12;
pub const NVML_API_VERSION_STR: &[u8; 3] = b"12\0";
pub const NVML_VALUE_NOT_AVAILABLE: i32 = -1;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE: u32 = 32;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE: u32 = 16;
pub const NVML_DEVICE_PCI_BUS_ID_LEGACY_FMT: &[u8; 17] = b"%04X:%02X:%02X.0\0";
pub const NVML_DEVICE_PCI_BUS_ID_FMT: &[u8; 17] = b"%08X:%02X:%02X.0\0";
pub const NVML_NVLINK_MAX_LINKS: u32 = 18;
pub const NVML_MAX_PHYSICAL_BRIDGE: u32 = 128;
pub const NVML_MAX_THERMAL_SENSORS_PER_GPU: u32 = 3;
pub const nvmlFlagDefault: u32 = 0;
pub const nvmlFlagForce: u32 = 1;
pub const MAX_CLK_DOMAINS: u32 = 32;
pub const NVML_MAX_GPU_PERF_PSTATES: u32 = 16;
pub const NVML_GRID_LICENSE_EXPIRY_NOT_AVAILABLE: u32 = 0;
pub const NVML_GRID_LICENSE_EXPIRY_INVALID: u32 = 1;
pub const NVML_GRID_LICENSE_EXPIRY_VALID: u32 = 2;
pub const NVML_GRID_LICENSE_EXPIRY_NOT_APPLICABLE: u32 = 3;
pub const NVML_GRID_LICENSE_EXPIRY_PERMANENT: u32 = 4;
pub const NVML_GRID_LICENSE_BUFFER_SIZE: u32 = 128;
pub const NVML_VGPU_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_GRID_LICENSE_FEATURE_MAX_COUNT: u32 = 3;
pub const INVALID_GPU_INSTANCE_PROFILE_ID: u32 = 4294967295;
pub const INVALID_GPU_INSTANCE_ID: u32 = 4294967295;
pub const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_VGPU_SCHEDULER_POLICY_UNKNOWN: u32 = 0;
pub const NVML_VGPU_SCHEDULER_POLICY_BEST_EFFORT: u32 = 1;
pub const NVML_VGPU_SCHEDULER_POLICY_EQUAL_SHARE: u32 = 2;
pub const NVML_VGPU_SCHEDULER_POLICY_FIXED_SHARE: u32 = 3;
pub const NVML_SUPPORTED_VGPU_SCHEDULER_POLICY_COUNT: u32 = 3;
pub const NVML_SCHEDULER_SW_MAX_LOG_ENTRIES: u32 = 200;
pub const NVML_VGPU_SCHEDULER_ARR_DEFAULT: u32 = 0;
pub const NVML_VGPU_SCHEDULER_ARR_DISABLE: u32 = 1;
pub const NVML_VGPU_SCHEDULER_ARR_ENABLE: u32 = 2;
pub const NVML_GRID_LICENSE_STATE_UNKNOWN: u32 = 0;
pub const NVML_GRID_LICENSE_STATE_UNINITIALIZED: u32 = 1;
pub const NVML_GRID_LICENSE_STATE_UNLICENSED_UNRESTRICTED: u32 = 2;
pub const NVML_GRID_LICENSE_STATE_UNLICENSED_RESTRICTED: u32 = 3;
pub const NVML_GRID_LICENSE_STATE_UNLICENSED: u32 = 4;
pub const NVML_GRID_LICENSE_STATE_LICENSED: u32 = 5;
pub const NVML_GSP_FIRMWARE_VERSION_BUF_SIZE: u32 = 64;
pub const NVML_DEVICE_ARCH_KEPLER: u32 = 2;
pub const NVML_DEVICE_ARCH_MAXWELL: u32 = 3;
pub const NVML_DEVICE_ARCH_PASCAL: u32 = 4;
pub const NVML_DEVICE_ARCH_VOLTA: u32 = 5;
pub const NVML_DEVICE_ARCH_TURING: u32 = 6;
pub const NVML_DEVICE_ARCH_AMPERE: u32 = 7;
pub const NVML_DEVICE_ARCH_ADA: u32 = 8;
pub const NVML_DEVICE_ARCH_HOPPER: u32 = 9;
pub const NVML_DEVICE_ARCH_UNKNOWN: u32 = 4294967295;
pub const NVML_BUS_TYPE_UNKNOWN: u32 = 0;
pub const NVML_BUS_TYPE_PCI: u32 = 1;
pub const NVML_BUS_TYPE_PCIE: u32 = 2;
pub const NVML_BUS_TYPE_FPCI: u32 = 3;
pub const NVML_BUS_TYPE_AGP: u32 = 4;
pub const NVML_FAN_POLICY_TEMPERATURE_CONTINOUS_SW: u32 = 0;
pub const NVML_FAN_POLICY_MANUAL: u32 = 1;
pub const NVML_POWER_SOURCE_AC: u32 = 0;
pub const NVML_POWER_SOURCE_BATTERY: u32 = 1;
pub const NVML_POWER_SOURCE_UNDERSIZED: u32 = 2;
pub const NVML_PCIE_LINK_MAX_SPEED_INVALID: u32 = 0;
pub const NVML_PCIE_LINK_MAX_SPEED_2500MBPS: u32 = 1;
pub const NVML_PCIE_LINK_MAX_SPEED_5000MBPS: u32 = 2;
pub const NVML_PCIE_LINK_MAX_SPEED_8000MBPS: u32 = 3;
pub const NVML_PCIE_LINK_MAX_SPEED_16000MBPS: u32 = 4;
pub const NVML_PCIE_LINK_MAX_SPEED_32000MBPS: u32 = 5;
pub const NVML_PCIE_LINK_MAX_SPEED_64000MBPS: u32 = 6;
pub const NVML_ADAPTIVE_CLOCKING_INFO_STATUS_DISABLED: u32 = 0;
pub const NVML_ADAPTIVE_CLOCKING_INFO_STATUS_ENABLED: u32 = 1;
pub const NVML_MAX_GPU_UTILIZATIONS: u32 = 8;
pub mod field_id {
    pub const NVML_FI_DEV_ECC_CURRENT: u32 = 1;
    pub const NVML_FI_DEV_ECC_PENDING: u32 = 2;
    pub const NVML_FI_DEV_ECC_SBE_VOL_TOTAL: u32 = 3;
    pub const NVML_FI_DEV_ECC_DBE_VOL_TOTAL: u32 = 4;
    pub const NVML_FI_DEV_ECC_SBE_AGG_TOTAL: u32 = 5;
    pub const NVML_FI_DEV_ECC_DBE_AGG_TOTAL: u32 = 6;
    pub const NVML_FI_DEV_ECC_SBE_VOL_L1: u32 = 7;
    pub const NVML_FI_DEV_ECC_DBE_VOL_L1: u32 = 8;
    pub const NVML_FI_DEV_ECC_SBE_VOL_L2: u32 = 9;
    pub const NVML_FI_DEV_ECC_DBE_VOL_L2: u32 = 10;
    pub const NVML_FI_DEV_ECC_SBE_VOL_DEV: u32 = 11;
    pub const NVML_FI_DEV_ECC_DBE_VOL_DEV: u32 = 12;
    pub const NVML_FI_DEV_ECC_SBE_VOL_REG: u32 = 13;
    pub const NVML_FI_DEV_ECC_DBE_VOL_REG: u32 = 14;
    pub const NVML_FI_DEV_ECC_SBE_VOL_TEX: u32 = 15;
    pub const NVML_FI_DEV_ECC_DBE_VOL_TEX: u32 = 16;
    pub const NVML_FI_DEV_ECC_DBE_VOL_CBU: u32 = 17;
    pub const NVML_FI_DEV_ECC_SBE_AGG_L1: u32 = 18;
    pub const NVML_FI_DEV_ECC_DBE_AGG_L1: u32 = 19;
    pub const NVML_FI_DEV_ECC_SBE_AGG_L2: u32 = 20;
    pub const NVML_FI_DEV_ECC_DBE_AGG_L2: u32 = 21;
    pub const NVML_FI_DEV_ECC_SBE_AGG_DEV: u32 = 22;
    pub const NVML_FI_DEV_ECC_DBE_AGG_DEV: u32 = 23;
    pub const NVML_FI_DEV_ECC_SBE_AGG_REG: u32 = 24;
    pub const NVML_FI_DEV_ECC_DBE_AGG_REG: u32 = 25;
    pub const NVML_FI_DEV_ECC_SBE_AGG_TEX: u32 = 26;
    pub const NVML_FI_DEV_ECC_DBE_AGG_TEX: u32 = 27;
    pub const NVML_FI_DEV_ECC_DBE_AGG_CBU: u32 = 28;
    pub const NVML_FI_DEV_RETIRED_SBE: u32 = 29;
    pub const NVML_FI_DEV_RETIRED_DBE: u32 = 30;
    pub const NVML_FI_DEV_RETIRED_PENDING: u32 = 31;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L0: u32 = 32;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L1: u32 = 33;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L2: u32 = 34;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L3: u32 = 35;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L4: u32 = 36;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L5: u32 = 37;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL: u32 = 38;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L0: u32 = 39;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L1: u32 = 40;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L2: u32 = 41;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L3: u32 = 42;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L4: u32 = 43;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L5: u32 = 44;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL: u32 = 45;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L0: u32 = 46;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L1: u32 = 47;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L2: u32 = 48;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L3: u32 = 49;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L4: u32 = 50;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L5: u32 = 51;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL: u32 = 52;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L0: u32 = 53;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L1: u32 = 54;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L2: u32 = 55;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L3: u32 = 56;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L4: u32 = 57;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L5: u32 = 58;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL: u32 = 59;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L0: u32 = 60;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L1: u32 = 61;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L2: u32 = 62;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L3: u32 = 63;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L4: u32 = 64;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L5: u32 = 65;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_TOTAL: u32 = 66;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L0: u32 = 67;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L1: u32 = 68;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L2: u32 = 69;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L3: u32 = 70;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L4: u32 = 71;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L5: u32 = 72;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_TOTAL: u32 = 73;
    pub const NVML_FI_DEV_PERF_POLICY_POWER: u32 = 74;
    pub const NVML_FI_DEV_PERF_POLICY_THERMAL: u32 = 75;
    pub const NVML_FI_DEV_PERF_POLICY_SYNC_BOOST: u32 = 76;
    pub const NVML_FI_DEV_PERF_POLICY_BOARD_LIMIT: u32 = 77;
    pub const NVML_FI_DEV_PERF_POLICY_LOW_UTILIZATION: u32 = 78;
    pub const NVML_FI_DEV_PERF_POLICY_RELIABILITY: u32 = 79;
    pub const NVML_FI_DEV_PERF_POLICY_TOTAL_APP_CLOCKS: u32 = 80;
    pub const NVML_FI_DEV_PERF_POLICY_TOTAL_BASE_CLOCKS: u32 = 81;
    pub const NVML_FI_DEV_MEMORY_TEMP: u32 = 82;
    pub const NVML_FI_DEV_TOTAL_ENERGY_CONSUMPTION: u32 = 83;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L0: u32 = 84;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L1: u32 = 85;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L2: u32 = 86;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L3: u32 = 87;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L4: u32 = 88;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L5: u32 = 89;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_COMMON: u32 = 90;
    pub const NVML_FI_DEV_NVLINK_LINK_COUNT: u32 = 91;
    pub const NVML_FI_DEV_RETIRED_PENDING_SBE: u32 = 92;
    pub const NVML_FI_DEV_RETIRED_PENDING_DBE: u32 = 93;
    pub const NVML_FI_DEV_PCIE_REPLAY_COUNTER: u32 = 94;
    pub const NVML_FI_DEV_PCIE_REPLAY_ROLLOVER_COUNTER: u32 = 95;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L6: u32 = 96;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L7: u32 = 97;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L8: u32 = 98;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L9: u32 = 99;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L10: u32 = 100;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L11: u32 = 101;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L6: u32 = 102;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L7: u32 = 103;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L8: u32 = 104;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L9: u32 = 105;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L10: u32 = 106;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L11: u32 = 107;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L6: u32 = 108;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L7: u32 = 109;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L8: u32 = 110;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L9: u32 = 111;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L10: u32 = 112;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L11: u32 = 113;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L6: u32 = 114;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L7: u32 = 115;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L8: u32 = 116;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L9: u32 = 117;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L10: u32 = 118;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L11: u32 = 119;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L6: u32 = 120;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L7: u32 = 121;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L8: u32 = 122;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L9: u32 = 123;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L10: u32 = 124;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L11: u32 = 125;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L6: u32 = 126;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L7: u32 = 127;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L8: u32 = 128;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L9: u32 = 129;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L10: u32 = 130;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L11: u32 = 131;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L6: u32 = 132;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L7: u32 = 133;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L8: u32 = 134;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L9: u32 = 135;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L10: u32 = 136;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L11: u32 = 137;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_TX: u32 = 138;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_RX: u32 = 139;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_TX: u32 = 140;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_RX: u32 = 141;
    pub const NVML_FI_DEV_REMAPPED_COR: u32 = 142;
    pub const NVML_FI_DEV_REMAPPED_UNC: u32 = 143;
    pub const NVML_FI_DEV_REMAPPED_PENDING: u32 = 144;
    pub const NVML_FI_DEV_REMAPPED_FAILURE: u32 = 145;
    pub const NVML_FI_DEV_NVLINK_REMOTE_NVLINK_ID: u32 = 146;
    pub const NVML_FI_DEV_NVSWITCH_CONNECTED_LINK_COUNT: u32 = 147;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L0: u32 = 148;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L1: u32 = 149;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L2: u32 = 150;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L3: u32 = 151;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L4: u32 = 152;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L5: u32 = 153;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L6: u32 = 154;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L7: u32 = 155;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L8: u32 = 156;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L9: u32 = 157;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L10: u32 = 158;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_L11: u32 = 159;
    pub const NVML_FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_TOTAL: u32 = 160;
    pub const NVML_FI_DEV_NVLINK_ERROR_DL_REPLAY: u32 = 161;
    pub const NVML_FI_DEV_NVLINK_ERROR_DL_RECOVERY: u32 = 162;
    pub const NVML_FI_DEV_NVLINK_ERROR_DL_CRC: u32 = 163;
    pub const NVML_FI_DEV_NVLINK_GET_SPEED: u32 = 164;
    pub const NVML_FI_DEV_NVLINK_GET_STATE: u32 = 165;
    pub const NVML_FI_DEV_NVLINK_GET_VERSION: u32 = 166;
    pub const NVML_FI_DEV_NVLINK_GET_POWER_STATE: u32 = 167;
    pub const NVML_FI_DEV_NVLINK_GET_POWER_THRESHOLD: u32 = 168;
    pub const NVML_FI_DEV_PCIE_L0_TO_RECOVERY_COUNTER: u32 = 169;
    pub const NVML_FI_DEV_C2C_LINK_COUNT: u32 = 170;
    pub const NVML_FI_DEV_C2C_LINK_GET_STATUS: u32 = 171;
    pub const NVML_FI_DEV_C2C_LINK_GET_MAX_BW: u32 = 172;
    pub const NVML_FI_DEV_PCIE_COUNT_CORRECTABLE_ERRORS: u32 = 173;
    pub const NVML_FI_DEV_PCIE_COUNT_NAKS_RECEIVED: u32 = 174;
    pub const NVML_FI_DEV_PCIE_COUNT_RECEIVER_ERROR: u32 = 175;
    pub const NVML_FI_DEV_PCIE_COUNT_BAD_TLP: u32 = 176;
    pub const NVML_FI_DEV_PCIE_COUNT_NAKS_SENT: u32 = 177;
    pub const NVML_FI_DEV_PCIE_COUNT_BAD_DLLP: u32 = 178;
    pub const NVML_FI_DEV_PCIE_COUNT_NON_FATAL_ERROR: u32 = 179;
    pub const NVML_FI_DEV_PCIE_COUNT_FATAL_ERROR: u32 = 180;
    pub const NVML_FI_DEV_PCIE_COUNT_UNSUPPORTED_REQ: u32 = 181;
    pub const NVML_FI_DEV_PCIE_COUNT_LCRC_ERROR: u32 = 182;
    pub const NVML_FI_DEV_PCIE_COUNT_LANE_ERROR: u32 = 183;
    pub const NVML_FI_DEV_IS_RESETLESS_MIG_SUPPORTED: u32 = 184;
    pub const NVML_FI_DEV_POWER_AVERAGE: u32 = 185;
    pub const NVML_FI_DEV_POWER_INSTANT: u32 = 186;
    pub const NVML_FI_DEV_POWER_MIN_LIMIT: u32 = 187;
    pub const NVML_FI_DEV_POWER_MAX_LIMIT: u32 = 188;
    pub const NVML_FI_DEV_POWER_DEFAULT_LIMIT: u32 = 189;
    pub const NVML_FI_DEV_POWER_CURRENT_LIMIT: u32 = 190;
    pub const NVML_FI_DEV_ENERGY: u32 = 191;
    pub const NVML_FI_DEV_POWER_REQUESTED_LIMIT: u32 = 192;
    pub const NVML_FI_DEV_TEMPERATURE_SHUTDOWN_TLIMIT: u32 = 193;
    pub const NVML_FI_DEV_TEMPERATURE_SLOWDOWN_TLIMIT: u32 = 194;
    pub const NVML_FI_DEV_TEMPERATURE_MEM_MAX_TLIMIT: u32 = 195;
    pub const NVML_FI_DEV_TEMPERATURE_GPU_MAX_TLIMIT: u32 = 196;
    pub const NVML_FI_MAX: u32 = 197;
}
pub const nvmlEventTypeSingleBitEccError: u32 = 1;
pub const nvmlEventTypeDoubleBitEccError: u32 = 2;
pub const nvmlEventTypePState: u32 = 4;
pub const nvmlEventTypeXidCriticalError: u32 = 8;
pub const nvmlEventTypeClock: u32 = 16;
pub const nvmlEventTypePowerSourceChange: u32 = 128;
pub const nvmlEventMigConfigChange: u32 = 256;
pub const nvmlEventTypeNone: u32 = 0;
pub const nvmlEventTypeAll: u32 = 415;
pub const nvmlClocksEventReasonGpuIdle: u32 = 1;
pub const nvmlClocksEventReasonApplicationsClocksSetting: u32 = 2;
pub const nvmlClocksThrottleReasonUserDefinedClocks: u32 = 2;
pub const nvmlClocksEventReasonSwPowerCap: u32 = 4;
pub const nvmlClocksThrottleReasonHwSlowdown: u32 = 8;
pub const nvmlClocksEventReasonSyncBoost: u32 = 16;
pub const nvmlClocksEventReasonSwThermalSlowdown: u32 = 32;
pub const nvmlClocksThrottleReasonHwThermalSlowdown: u32 = 64;
pub const nvmlClocksThrottleReasonHwPowerBrakeSlowdown: u32 = 128;
pub const nvmlClocksEventReasonDisplayClockSetting: u32 = 256;
pub const nvmlClocksEventReasonNone: u32 = 0;
pub const nvmlClocksThrottleReasonGpuIdle: u32 = 1;
pub const nvmlClocksThrottleReasonApplicationsClocksSetting: u32 = 2;
pub const nvmlClocksThrottleReasonSyncBoost: u32 = 16;
pub const nvmlClocksThrottleReasonSwPowerCap: u32 = 4;
pub const nvmlClocksThrottleReasonSwThermalSlowdown: u32 = 32;
pub const nvmlClocksThrottleReasonDisplayClockSetting: u32 = 256;
pub const nvmlClocksThrottleReasonNone: u32 = 0;
pub const NVML_NVFBC_SESSION_FLAG_DIFFMAP_ENABLED: u32 = 1;
pub const NVML_NVFBC_SESSION_FLAG_CLASSIFICATIONMAP_ENABLED: u32 = 2;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_NO_WAIT: u32 = 4;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_INFINITE: u32 = 8;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_TIMEOUT: u32 = 16;
pub const NVML_CC_SYSTEM_CPU_CAPS_NONE: u32 = 0;
pub const NVML_CC_SYSTEM_CPU_CAPS_AMD_SEV: u32 = 1;
pub const NVML_CC_SYSTEM_CPU_CAPS_INTEL_TDX: u32 = 2;
pub const NVML_CC_SYSTEM_GPUS_CC_NOT_CAPABLE: u32 = 0;
pub const NVML_CC_SYSTEM_GPUS_CC_CAPABLE: u32 = 1;
pub const NVML_CC_SYSTEM_DEVTOOLS_MODE_OFF: u32 = 0;
pub const NVML_CC_SYSTEM_DEVTOOLS_MODE_ON: u32 = 1;
pub const NVML_CC_SYSTEM_ENVIRONMENT_UNAVAILABLE: u32 = 0;
pub const NVML_CC_SYSTEM_ENVIRONMENT_SIM: u32 = 1;
pub const NVML_CC_SYSTEM_ENVIRONMENT_PROD: u32 = 2;
pub const NVML_CC_SYSTEM_FEATURE_DISABLED: u32 = 0;
pub const NVML_CC_SYSTEM_FEATURE_ENABLED: u32 = 1;
pub const NVML_CC_ACCEPTING_CLIENT_REQUESTS_FALSE: u32 = 0;
pub const NVML_CC_ACCEPTING_CLIENT_REQUESTS_TRUE: u32 = 1;
pub const NVML_GPU_CERT_CHAIN_SIZE: u32 = 4096;
pub const NVML_GPU_ATTESTATION_CERT_CHAIN_SIZE: u32 = 5120;
pub const NVML_CC_GPU_CEC_NONCE_SIZE: u32 = 32;
pub const NVML_CC_GPU_ATTESTATION_REPORT_SIZE: u32 = 8192;
pub const NVML_CC_GPU_CEC_ATTESTATION_REPORT_SIZE: u32 = 4096;
pub const NVML_CC_CEC_ATTESTATION_REPORT_NOT_PRESENT: u32 = 0;
pub const NVML_CC_CEC_ATTESTATION_REPORT_PRESENT: u32 = 1;
pub const NVML_GPU_FABRIC_UUID_LEN: u32 = 16;
pub const NVML_GPU_FABRIC_STATE_NOT_SUPPORTED: u32 = 0;
pub const NVML_GPU_FABRIC_STATE_NOT_STARTED: u32 = 1;
pub const NVML_GPU_FABRIC_STATE_IN_PROGRESS: u32 = 2;
pub const NVML_GPU_FABRIC_STATE_COMPLETED: u32 = 3;
pub const NVML_POWER_SCOPE_GPU: u32 = 0;
pub const NVML_POWER_SCOPE_MODULE: u32 = 1;
pub const NVML_INIT_FLAG_NO_GPUS: u32 = 1;
pub const NVML_INIT_FLAG_NO_ATTACH: u32 = 2;
pub const NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE: u32 = 16;
pub const NVML_DEVICE_UUID_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_UUID_V2_BUFFER_SIZE: u32 = 96;
pub const NVML_DEVICE_PART_NUMBER_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_DEVICE_NAME_V2_BUFFER_SIZE: u32 = 96;
pub const NVML_DEVICE_SERIAL_BUFFER_SIZE: u32 = 30;
pub const NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE: u32 = 32;
pub const NVML_AFFINITY_SCOPE_NODE: u32 = 0;
pub const NVML_AFFINITY_SCOPE_SOCKET: u32 = 1;
pub const NVML_DEVICE_MIG_DISABLE: u32 = 0;
pub const NVML_DEVICE_MIG_ENABLE: u32 = 1;
pub const NVML_GPU_INSTANCE_PROFILE_1_SLICE: u32 = 0;
pub const NVML_GPU_INSTANCE_PROFILE_2_SLICE: u32 = 1;
pub const NVML_GPU_INSTANCE_PROFILE_3_SLICE: u32 = 2;
pub const NVML_GPU_INSTANCE_PROFILE_4_SLICE: u32 = 3;
pub const NVML_GPU_INSTANCE_PROFILE_7_SLICE: u32 = 4;
pub const NVML_GPU_INSTANCE_PROFILE_8_SLICE: u32 = 5;
pub const NVML_GPU_INSTANCE_PROFILE_6_SLICE: u32 = 6;
pub const NVML_GPU_INSTANCE_PROFILE_1_SLICE_REV1: u32 = 7;
pub const NVML_GPU_INSTANCE_PROFILE_2_SLICE_REV1: u32 = 8;
pub const NVML_GPU_INSTANCE_PROFILE_1_SLICE_REV2: u32 = 9;
pub const NVML_GPU_INSTANCE_PROFILE_COUNT: u32 = 10;
pub const NVML_COMPUTE_INSTANCE_PROFILE_1_SLICE: u32 = 0;
pub const NVML_COMPUTE_INSTANCE_PROFILE_2_SLICE: u32 = 1;
pub const NVML_COMPUTE_INSTANCE_PROFILE_3_SLICE: u32 = 2;
pub const NVML_COMPUTE_INSTANCE_PROFILE_4_SLICE: u32 = 3;
pub const NVML_COMPUTE_INSTANCE_PROFILE_7_SLICE: u32 = 4;
pub const NVML_COMPUTE_INSTANCE_PROFILE_8_SLICE: u32 = 5;
pub const NVML_COMPUTE_INSTANCE_PROFILE_6_SLICE: u32 = 6;
pub const NVML_COMPUTE_INSTANCE_PROFILE_1_SLICE_REV1: u32 = 7;
pub const NVML_COMPUTE_INSTANCE_PROFILE_COUNT: u32 = 8;
pub const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_SHARED: u32 = 0;
pub const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_COUNT: u32 = 1;
pub const NVML_GPM_METRICS_GET_VERSION: u32 = 1;
pub const NVML_GPM_SUPPORT_VERSION: u32 = 1;
pub const NVML_NVLINK_POWER_STATE_HIGH_SPEED: u32 = 0;
pub const NVML_NVLINK_POWER_STATE_LOW: u32 = 1;
pub const NVML_NVLINK_LOW_POWER_THRESHOLD_MIN: u32 = 1;
pub const NVML_NVLINK_LOW_POWER_THRESHOLD_MAX: u32 = 8191;
pub const NVML_NVLINK_LOW_POWER_THRESHOLD_RESET: u32 = 4294967295;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlDevice_st {
    _unused: [u8; 0],
}
pub type nvmlDevice_t = *mut nvmlDevice_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlPciInfo_st {
    pub busIdLegacy: [raw::c_char; 16usize],
    pub domain: raw::c_uint,
    pub bus: raw::c_uint,
    pub device: raw::c_uint,
    pub pciDeviceId: raw::c_uint,
    pub pciSubSystemId: raw::c_uint,
    pub busId: [raw::c_char; 32usize],
}
pub type nvmlPciInfo_t = nvmlPciInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEccErrorCounts_st {
    pub l1Cache: raw::c_ulonglong,
    pub l2Cache: raw::c_ulonglong,
    pub deviceMemory: raw::c_ulonglong,
    pub registerFile: raw::c_ulonglong,
}
pub type nvmlEccErrorCounts_t = nvmlEccErrorCounts_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUtilization_st {
    pub gpu: raw::c_uint,
    pub memory: raw::c_uint,
}
pub type nvmlUtilization_t = nvmlUtilization_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlMemory_st {
    pub total: raw::c_ulonglong,
    pub free: raw::c_ulonglong,
    pub used: raw::c_ulonglong,
}
pub type nvmlMemory_t = nvmlMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlMemory_v2_st {
    pub version: raw::c_uint,
    pub total: raw::c_ulonglong,
    pub reserved: raw::c_ulonglong,
    pub free: raw::c_ulonglong,
    pub used: raw::c_ulonglong,
}
pub type nvmlMemory_v2_t = nvmlMemory_v2_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlBAR1Memory_st {
    pub bar1Total: raw::c_ulonglong,
    pub bar1Free: raw::c_ulonglong,
    pub bar1Used: raw::c_ulonglong,
}
pub type nvmlBAR1Memory_t = nvmlBAR1Memory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessInfo_v1_st {
    pub pid: raw::c_uint,
    pub usedGpuMemory: raw::c_ulonglong,
}
pub type nvmlProcessInfo_v1_t = nvmlProcessInfo_v1_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessInfo_v2_st {
    pub pid: raw::c_uint,
    pub usedGpuMemory: raw::c_ulonglong,
    pub gpuInstanceId: raw::c_uint,
    pub computeInstanceId: raw::c_uint,
}
pub type nvmlProcessInfo_v2_t = nvmlProcessInfo_v2_st;
pub type nvmlProcessInfo_t = nvmlProcessInfo_v2_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessDetail_v1_t {
    pub pid: raw::c_uint,
    pub usedGpuMemory: raw::c_ulonglong,
    pub gpuInstanceId: raw::c_uint,
    pub computeInstanceId: raw::c_uint,
    pub usedGpuCcProtectedMemory: raw::c_ulonglong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessDetailList_v1_t {
    pub version: raw::c_uint,
    pub mode: raw::c_uint,
    pub numProcArrayEntries: raw::c_uint,
    pub procArray: *mut nvmlProcessDetail_v1_t,
}
pub type nvmlProcessDetailList_t = nvmlProcessDetailList_v1_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlDeviceAttributes_st {
    pub multiprocessorCount: raw::c_uint,
    pub sharedCopyEngineCount: raw::c_uint,
    pub sharedDecoderCount: raw::c_uint,
    pub sharedEncoderCount: raw::c_uint,
    pub sharedJpegCount: raw::c_uint,
    pub sharedOfaCount: raw::c_uint,
    pub gpuInstanceSliceCount: raw::c_uint,
    pub computeInstanceSliceCount: raw::c_uint,
    pub memorySizeMB: raw::c_ulonglong,
}
pub type nvmlDeviceAttributes_t = nvmlDeviceAttributes_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlRowRemapperHistogramValues_st {
    pub max: raw::c_uint,
    pub high: raw::c_uint,
    pub partial: raw::c_uint,
    pub low: raw::c_uint,
    pub none: raw::c_uint,
}
pub type nvmlRowRemapperHistogramValues_t = nvmlRowRemapperHistogramValues_st;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_PLX: nvmlBridgeChipType_enum = 0;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_BRO4: nvmlBridgeChipType_enum = 1;
pub type nvmlBridgeChipType_enum = raw::c_uint;
pub use self::nvmlBridgeChipType_enum as nvmlBridgeChipType_t;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_CYCLES:
    nvmlNvLinkUtilizationCountUnits_enum = 0;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_PACKETS:
    nvmlNvLinkUtilizationCountUnits_enum = 1;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_BYTES:
    nvmlNvLinkUtilizationCountUnits_enum = 2;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_RESERVED:
    nvmlNvLinkUtilizationCountUnits_enum = 3;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_COUNT:
    nvmlNvLinkUtilizationCountUnits_enum = 4;
pub type nvmlNvLinkUtilizationCountUnits_enum = raw::c_uint;
pub use self::nvmlNvLinkUtilizationCountUnits_enum as nvmlNvLinkUtilizationCountUnits_t;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NOP:
    nvmlNvLinkUtilizationCountPktTypes_enum = 1;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_READ:
    nvmlNvLinkUtilizationCountPktTypes_enum = 2;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_WRITE:
    nvmlNvLinkUtilizationCountPktTypes_enum = 4;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RATOM:
    nvmlNvLinkUtilizationCountPktTypes_enum = 8;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NRATOM:
    nvmlNvLinkUtilizationCountPktTypes_enum = 16;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_FLUSH:
    nvmlNvLinkUtilizationCountPktTypes_enum = 32;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA:
    nvmlNvLinkUtilizationCountPktTypes_enum = 64;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA:
    nvmlNvLinkUtilizationCountPktTypes_enum = 128;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_ALL:
    nvmlNvLinkUtilizationCountPktTypes_enum = 255;
pub type nvmlNvLinkUtilizationCountPktTypes_enum = raw::c_uint;
pub use self::nvmlNvLinkUtilizationCountPktTypes_enum as nvmlNvLinkUtilizationCountPktTypes_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlNvLinkUtilizationControl_st {
    pub units: nvmlNvLinkUtilizationCountUnits_t,
    pub pktfilter: nvmlNvLinkUtilizationCountPktTypes_t,
}
pub type nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_SUPPORTED: nvmlNvLinkCapability_enum = 0;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ACCESS: nvmlNvLinkCapability_enum = 1;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_ATOMICS: nvmlNvLinkCapability_enum = 2;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ATOMICS: nvmlNvLinkCapability_enum = 3;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SLI_BRIDGE: nvmlNvLinkCapability_enum = 4;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_VALID: nvmlNvLinkCapability_enum = 5;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_COUNT: nvmlNvLinkCapability_enum = 6;
pub type nvmlNvLinkCapability_enum = raw::c_uint;
pub use self::nvmlNvLinkCapability_enum as nvmlNvLinkCapability_t;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_REPLAY: nvmlNvLinkErrorCounter_enum = 0;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_RECOVERY: nvmlNvLinkErrorCounter_enum =
    1;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_FLIT: nvmlNvLinkErrorCounter_enum =
    2;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_DATA: nvmlNvLinkErrorCounter_enum =
    3;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_ECC_DATA: nvmlNvLinkErrorCounter_enum =
    4;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_COUNT: nvmlNvLinkErrorCounter_enum = 5;
pub type nvmlNvLinkErrorCounter_enum = raw::c_uint;
pub use self::nvmlNvLinkErrorCounter_enum as nvmlNvLinkErrorCounter_t;
pub const nvmlIntNvLinkDeviceType_enum_NVML_NVLINK_DEVICE_TYPE_GPU: nvmlIntNvLinkDeviceType_enum =
    0;
pub const nvmlIntNvLinkDeviceType_enum_NVML_NVLINK_DEVICE_TYPE_IBMNPU:
    nvmlIntNvLinkDeviceType_enum = 1;
pub const nvmlIntNvLinkDeviceType_enum_NVML_NVLINK_DEVICE_TYPE_SWITCH:
    nvmlIntNvLinkDeviceType_enum = 2;
pub const nvmlIntNvLinkDeviceType_enum_NVML_NVLINK_DEVICE_TYPE_UNKNOWN:
    nvmlIntNvLinkDeviceType_enum = 255;
pub type nvmlIntNvLinkDeviceType_enum = raw::c_uint;
pub use self::nvmlIntNvLinkDeviceType_enum as nvmlIntNvLinkDeviceType_t;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_INTERNAL: nvmlGpuLevel_enum = 0;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SINGLE: nvmlGpuLevel_enum = 10;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_MULTIPLE: nvmlGpuLevel_enum = 20;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_HOSTBRIDGE: nvmlGpuLevel_enum = 30;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_NODE: nvmlGpuLevel_enum = 40;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SYSTEM: nvmlGpuLevel_enum = 50;
pub type nvmlGpuLevel_enum = raw::c_uint;
pub use self::nvmlGpuLevel_enum as nvmlGpuTopologyLevel_t;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_OK: nvmlGpuP2PStatus_enum = 0;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED: nvmlGpuP2PStatus_enum = 1;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_CHIPSET_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 1;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_GPU_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 2;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED: nvmlGpuP2PStatus_enum =
    3;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_DISABLED_BY_REGKEY: nvmlGpuP2PStatus_enum = 4;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 5;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_UNKNOWN: nvmlGpuP2PStatus_enum = 6;
pub type nvmlGpuP2PStatus_enum = raw::c_uint;
pub use self::nvmlGpuP2PStatus_enum as nvmlGpuP2PStatus_t;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_READ: nvmlGpuP2PCapsIndex_enum = 0;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_WRITE: nvmlGpuP2PCapsIndex_enum = 1;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_NVLINK: nvmlGpuP2PCapsIndex_enum = 2;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_ATOMICS: nvmlGpuP2PCapsIndex_enum = 3;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_PROP: nvmlGpuP2PCapsIndex_enum = 4;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_UNKNOWN: nvmlGpuP2PCapsIndex_enum = 5;
pub type nvmlGpuP2PCapsIndex_enum = raw::c_uint;
pub use self::nvmlGpuP2PCapsIndex_enum as nvmlGpuP2PCapsIndex_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlBridgeChipInfo_st {
    pub type_: nvmlBridgeChipType_t,
    pub fwVersion: raw::c_uint,
}
pub type nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlBridgeChipHierarchy_st {
    pub bridgeCount: raw::c_uchar,
    pub bridgeChipInfo: [nvmlBridgeChipInfo_t; 128usize],
}
pub type nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st;
pub const nvmlSamplingType_enum_NVML_TOTAL_POWER_SAMPLES: nvmlSamplingType_enum = 0;
pub const nvmlSamplingType_enum_NVML_GPU_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 1;
pub const nvmlSamplingType_enum_NVML_MEMORY_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 2;
pub const nvmlSamplingType_enum_NVML_ENC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 3;
pub const nvmlSamplingType_enum_NVML_DEC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 4;
pub const nvmlSamplingType_enum_NVML_PROCESSOR_CLK_SAMPLES: nvmlSamplingType_enum = 5;
pub const nvmlSamplingType_enum_NVML_MEMORY_CLK_SAMPLES: nvmlSamplingType_enum = 6;
pub const nvmlSamplingType_enum_NVML_MODULE_POWER_SAMPLES: nvmlSamplingType_enum = 7;
pub const nvmlSamplingType_enum_NVML_SAMPLINGTYPE_COUNT: nvmlSamplingType_enum = 8;
pub type nvmlSamplingType_enum = raw::c_uint;
pub use self::nvmlSamplingType_enum as nvmlSamplingType_t;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_TX_BYTES: nvmlPcieUtilCounter_enum = 0;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_RX_BYTES: nvmlPcieUtilCounter_enum = 1;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_COUNT: nvmlPcieUtilCounter_enum = 2;
pub type nvmlPcieUtilCounter_enum = raw::c_uint;
pub use self::nvmlPcieUtilCounter_enum as nvmlPcieUtilCounter_t;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_DOUBLE: nvmlValueType_enum = 0;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_INT: nvmlValueType_enum = 1;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG: nvmlValueType_enum = 2;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG_LONG: nvmlValueType_enum = 3;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_SIGNED_LONG_LONG: nvmlValueType_enum = 4;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_SIGNED_INT: nvmlValueType_enum = 5;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_COUNT: nvmlValueType_enum = 6;
pub type nvmlValueType_enum = raw::c_uint;
pub use self::nvmlValueType_enum as nvmlValueType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlValue_st {
    pub dVal: f64,
    pub siVal: raw::c_int,
    pub uiVal: raw::c_uint,
    pub ulVal: raw::c_ulong,
    pub ullVal: raw::c_ulonglong,
    pub sllVal: raw::c_longlong,
}
pub type nvmlValue_t = nvmlValue_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlSample_st {
    pub timeStamp: raw::c_ulonglong,
    pub sampleValue: nvmlValue_t,
}
pub type nvmlSample_t = nvmlSample_st;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_POWER: nvmlPerfPolicyType_enum = 0;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_THERMAL: nvmlPerfPolicyType_enum = 1;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_SYNC_BOOST: nvmlPerfPolicyType_enum = 2;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_BOARD_LIMIT: nvmlPerfPolicyType_enum = 3;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_LOW_UTILIZATION: nvmlPerfPolicyType_enum = 4;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_RELIABILITY: nvmlPerfPolicyType_enum = 5;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_APP_CLOCKS: nvmlPerfPolicyType_enum = 10;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_BASE_CLOCKS: nvmlPerfPolicyType_enum = 11;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_COUNT: nvmlPerfPolicyType_enum = 12;
pub type nvmlPerfPolicyType_enum = raw::c_uint;
pub use self::nvmlPerfPolicyType_enum as nvmlPerfPolicyType_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlViolationTime_st {
    pub referenceTime: raw::c_ulonglong,
    pub violationTime: raw::c_ulonglong,
}
pub type nvmlViolationTime_t = nvmlViolationTime_st;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_NONE: nvmlThermalTarget_t = 0;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_GPU: nvmlThermalTarget_t = 1;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_MEMORY: nvmlThermalTarget_t = 2;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_POWER_SUPPLY: nvmlThermalTarget_t = 4;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_BOARD: nvmlThermalTarget_t = 8;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_VCD_BOARD: nvmlThermalTarget_t = 9;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_VCD_INLET: nvmlThermalTarget_t = 10;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_VCD_OUTLET: nvmlThermalTarget_t = 11;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_ALL: nvmlThermalTarget_t = 15;
pub const nvmlThermalTarget_t_NVML_THERMAL_TARGET_UNKNOWN: nvmlThermalTarget_t = -1;
pub type nvmlThermalTarget_t = raw::c_int;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_NONE: nvmlThermalController_t = 0;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_GPU_INTERNAL: nvmlThermalController_t = 1;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_ADM1032: nvmlThermalController_t = 2;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_ADT7461: nvmlThermalController_t = 3;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_MAX6649: nvmlThermalController_t = 4;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_MAX1617: nvmlThermalController_t = 5;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_LM99: nvmlThermalController_t = 6;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_LM89: nvmlThermalController_t = 7;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_LM64: nvmlThermalController_t = 8;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_G781: nvmlThermalController_t = 9;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_ADT7473: nvmlThermalController_t = 10;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_SBMAX6649: nvmlThermalController_t = 11;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_VBIOSEVT: nvmlThermalController_t = 12;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_OS: nvmlThermalController_t = 13;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_NVSYSCON_CANOAS: nvmlThermalController_t =
    14;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_NVSYSCON_E551: nvmlThermalController_t =
    15;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_MAX6649R: nvmlThermalController_t = 16;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_ADT7473S: nvmlThermalController_t = 17;
pub const nvmlThermalController_t_NVML_THERMAL_CONTROLLER_UNKNOWN: nvmlThermalController_t = -1;
pub type nvmlThermalController_t = raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuThermalSettings_t {
    pub count: raw::c_uint,
    pub sensor: [nvmlGpuThermalSettings_t__bindgen_ty_1; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuThermalSettings_t__bindgen_ty_1 {
    pub controller: nvmlThermalController_t,
    pub defaultMinTemp: raw::c_int,
    pub defaultMaxTemp: raw::c_int,
    pub currentTemp: raw::c_int,
    pub target: nvmlThermalTarget_t,
}
pub const nvmlEnableState_enum_NVML_FEATURE_DISABLED: nvmlEnableState_enum = 0;
pub const nvmlEnableState_enum_NVML_FEATURE_ENABLED: nvmlEnableState_enum = 1;
pub type nvmlEnableState_enum = raw::c_uint;
pub use self::nvmlEnableState_enum as nvmlEnableState_t;
pub const nvmlBrandType_enum_NVML_BRAND_UNKNOWN: nvmlBrandType_enum = 0;
pub const nvmlBrandType_enum_NVML_BRAND_QUADRO: nvmlBrandType_enum = 1;
pub const nvmlBrandType_enum_NVML_BRAND_TESLA: nvmlBrandType_enum = 2;
pub const nvmlBrandType_enum_NVML_BRAND_NVS: nvmlBrandType_enum = 3;
pub const nvmlBrandType_enum_NVML_BRAND_GRID: nvmlBrandType_enum = 4;
pub const nvmlBrandType_enum_NVML_BRAND_GEFORCE: nvmlBrandType_enum = 5;
pub const nvmlBrandType_enum_NVML_BRAND_TITAN: nvmlBrandType_enum = 6;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_VAPPS: nvmlBrandType_enum = 7;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_VPC: nvmlBrandType_enum = 8;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_VCS: nvmlBrandType_enum = 9;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_VWS: nvmlBrandType_enum = 10;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_CLOUD_GAMING: nvmlBrandType_enum = 11;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_VGAMING: nvmlBrandType_enum = 11;
pub const nvmlBrandType_enum_NVML_BRAND_QUADRO_RTX: nvmlBrandType_enum = 12;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA_RTX: nvmlBrandType_enum = 13;
pub const nvmlBrandType_enum_NVML_BRAND_NVIDIA: nvmlBrandType_enum = 14;
pub const nvmlBrandType_enum_NVML_BRAND_GEFORCE_RTX: nvmlBrandType_enum = 15;
pub const nvmlBrandType_enum_NVML_BRAND_TITAN_RTX: nvmlBrandType_enum = 16;
pub const nvmlBrandType_enum_NVML_BRAND_COUNT: nvmlBrandType_enum = 17;
pub type nvmlBrandType_enum = raw::c_uint;
pub use self::nvmlBrandType_enum as nvmlBrandType_t;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SHUTDOWN:
    nvmlTemperatureThresholds_enum = 0;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SLOWDOWN:
    nvmlTemperatureThresholds_enum = 1;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_MEM_MAX:
    nvmlTemperatureThresholds_enum = 2;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_GPU_MAX:
    nvmlTemperatureThresholds_enum = 3;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_MIN:
    nvmlTemperatureThresholds_enum = 4;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_CURR:
    nvmlTemperatureThresholds_enum = 5;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_ACOUSTIC_MAX:
    nvmlTemperatureThresholds_enum = 6;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_COUNT:
    nvmlTemperatureThresholds_enum = 7;
pub type nvmlTemperatureThresholds_enum = raw::c_uint;
pub use self::nvmlTemperatureThresholds_enum as nvmlTemperatureThresholds_t;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_GPU: nvmlTemperatureSensors_enum = 0;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_COUNT: nvmlTemperatureSensors_enum = 1;
pub type nvmlTemperatureSensors_enum = raw::c_uint;
pub use self::nvmlTemperatureSensors_enum as nvmlTemperatureSensors_t;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_DEFAULT: nvmlComputeMode_enum = 0;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_THREAD: nvmlComputeMode_enum = 1;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_PROHIBITED: nvmlComputeMode_enum = 2;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_PROCESS: nvmlComputeMode_enum = 3;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_COUNT: nvmlComputeMode_enum = 4;
pub type nvmlComputeMode_enum = raw::c_uint;
pub use self::nvmlComputeMode_enum as nvmlComputeMode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlClkMonFaultInfo_struct {
    pub clkApiDomain: raw::c_uint,
    pub clkDomainFaultMask: raw::c_uint,
}
pub type nvmlClkMonFaultInfo_t = nvmlClkMonFaultInfo_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlClkMonStatus_status {
    pub bGlobalStatus: raw::c_uint,
    pub clkMonListSize: raw::c_uint,
    pub clkMonList: [nvmlClkMonFaultInfo_t; 32usize],
}
pub type nvmlClkMonStatus_t = nvmlClkMonStatus_status;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_CORRECTED: nvmlMemoryErrorType_enum = 0;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_UNCORRECTED: nvmlMemoryErrorType_enum = 1;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_COUNT: nvmlMemoryErrorType_enum = 2;
pub type nvmlMemoryErrorType_enum = raw::c_uint;
pub use self::nvmlMemoryErrorType_enum as nvmlMemoryErrorType_t;
pub const nvmlEccCounterType_enum_NVML_VOLATILE_ECC: nvmlEccCounterType_enum = 0;
pub const nvmlEccCounterType_enum_NVML_AGGREGATE_ECC: nvmlEccCounterType_enum = 1;
pub const nvmlEccCounterType_enum_NVML_ECC_COUNTER_TYPE_COUNT: nvmlEccCounterType_enum = 2;
pub type nvmlEccCounterType_enum = raw::c_uint;
pub use self::nvmlEccCounterType_enum as nvmlEccCounterType_t;
pub const nvmlClockType_enum_NVML_CLOCK_GRAPHICS: nvmlClockType_enum = 0;
pub const nvmlClockType_enum_NVML_CLOCK_SM: nvmlClockType_enum = 1;
pub const nvmlClockType_enum_NVML_CLOCK_MEM: nvmlClockType_enum = 2;
pub const nvmlClockType_enum_NVML_CLOCK_VIDEO: nvmlClockType_enum = 3;
pub const nvmlClockType_enum_NVML_CLOCK_COUNT: nvmlClockType_enum = 4;
pub type nvmlClockType_enum = raw::c_uint;
pub use self::nvmlClockType_enum as nvmlClockType_t;
pub const nvmlClockId_enum_NVML_CLOCK_ID_CURRENT: nvmlClockId_enum = 0;
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_TARGET: nvmlClockId_enum = 1;
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_DEFAULT: nvmlClockId_enum = 2;
pub const nvmlClockId_enum_NVML_CLOCK_ID_CUSTOMER_BOOST_MAX: nvmlClockId_enum = 3;
pub const nvmlClockId_enum_NVML_CLOCK_ID_COUNT: nvmlClockId_enum = 4;
pub type nvmlClockId_enum = raw::c_uint;
pub use self::nvmlClockId_enum as nvmlClockId_t;
pub const nvmlDriverModel_enum_NVML_DRIVER_WDDM: nvmlDriverModel_enum = 0;
pub const nvmlDriverModel_enum_NVML_DRIVER_WDM: nvmlDriverModel_enum = 1;
pub type nvmlDriverModel_enum = raw::c_uint;
pub use self::nvmlDriverModel_enum as nvmlDriverModel_t;
pub const nvmlPStates_enum_NVML_PSTATE_0: nvmlPStates_enum = 0;
pub const nvmlPStates_enum_NVML_PSTATE_1: nvmlPStates_enum = 1;
pub const nvmlPStates_enum_NVML_PSTATE_2: nvmlPStates_enum = 2;
pub const nvmlPStates_enum_NVML_PSTATE_3: nvmlPStates_enum = 3;
pub const nvmlPStates_enum_NVML_PSTATE_4: nvmlPStates_enum = 4;
pub const nvmlPStates_enum_NVML_PSTATE_5: nvmlPStates_enum = 5;
pub const nvmlPStates_enum_NVML_PSTATE_6: nvmlPStates_enum = 6;
pub const nvmlPStates_enum_NVML_PSTATE_7: nvmlPStates_enum = 7;
pub const nvmlPStates_enum_NVML_PSTATE_8: nvmlPStates_enum = 8;
pub const nvmlPStates_enum_NVML_PSTATE_9: nvmlPStates_enum = 9;
pub const nvmlPStates_enum_NVML_PSTATE_10: nvmlPStates_enum = 10;
pub const nvmlPStates_enum_NVML_PSTATE_11: nvmlPStates_enum = 11;
pub const nvmlPStates_enum_NVML_PSTATE_12: nvmlPStates_enum = 12;
pub const nvmlPStates_enum_NVML_PSTATE_13: nvmlPStates_enum = 13;
pub const nvmlPStates_enum_NVML_PSTATE_14: nvmlPStates_enum = 14;
pub const nvmlPStates_enum_NVML_PSTATE_15: nvmlPStates_enum = 15;
pub const nvmlPStates_enum_NVML_PSTATE_UNKNOWN: nvmlPStates_enum = 32;
pub type nvmlPStates_enum = raw::c_uint;
pub use self::nvmlPStates_enum as nvmlPstates_t;
pub const nvmlGom_enum_NVML_GOM_ALL_ON: nvmlGom_enum = 0;
pub const nvmlGom_enum_NVML_GOM_COMPUTE: nvmlGom_enum = 1;
pub const nvmlGom_enum_NVML_GOM_LOW_DP: nvmlGom_enum = 2;
pub type nvmlGom_enum = raw::c_uint;
pub use self::nvmlGom_enum as nvmlGpuOperationMode_t;
pub const nvmlInforomObject_enum_NVML_INFOROM_OEM: nvmlInforomObject_enum = 0;
pub const nvmlInforomObject_enum_NVML_INFOROM_ECC: nvmlInforomObject_enum = 1;
pub const nvmlInforomObject_enum_NVML_INFOROM_POWER: nvmlInforomObject_enum = 2;
pub const nvmlInforomObject_enum_NVML_INFOROM_COUNT: nvmlInforomObject_enum = 3;
pub type nvmlInforomObject_enum = raw::c_uint;
pub use self::nvmlInforomObject_enum as nvmlInforomObject_t;
pub const nvmlReturn_enum_NVML_SUCCESS: nvmlReturn_enum = 0;
pub const nvmlReturn_enum_NVML_ERROR_UNINITIALIZED: nvmlReturn_enum = 1;
pub const nvmlReturn_enum_NVML_ERROR_INVALID_ARGUMENT: nvmlReturn_enum = 2;
pub const nvmlReturn_enum_NVML_ERROR_NOT_SUPPORTED: nvmlReturn_enum = 3;
pub const nvmlReturn_enum_NVML_ERROR_NO_PERMISSION: nvmlReturn_enum = 4;
pub const nvmlReturn_enum_NVML_ERROR_ALREADY_INITIALIZED: nvmlReturn_enum = 5;
pub const nvmlReturn_enum_NVML_ERROR_NOT_FOUND: nvmlReturn_enum = 6;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_SIZE: nvmlReturn_enum = 7;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_POWER: nvmlReturn_enum = 8;
pub const nvmlReturn_enum_NVML_ERROR_DRIVER_NOT_LOADED: nvmlReturn_enum = 9;
pub const nvmlReturn_enum_NVML_ERROR_TIMEOUT: nvmlReturn_enum = 10;
pub const nvmlReturn_enum_NVML_ERROR_IRQ_ISSUE: nvmlReturn_enum = 11;
pub const nvmlReturn_enum_NVML_ERROR_LIBRARY_NOT_FOUND: nvmlReturn_enum = 12;
pub const nvmlReturn_enum_NVML_ERROR_FUNCTION_NOT_FOUND: nvmlReturn_enum = 13;
pub const nvmlReturn_enum_NVML_ERROR_CORRUPTED_INFOROM: nvmlReturn_enum = 14;
pub const nvmlReturn_enum_NVML_ERROR_GPU_IS_LOST: nvmlReturn_enum = 15;
pub const nvmlReturn_enum_NVML_ERROR_RESET_REQUIRED: nvmlReturn_enum = 16;
pub const nvmlReturn_enum_NVML_ERROR_OPERATING_SYSTEM: nvmlReturn_enum = 17;
pub const nvmlReturn_enum_NVML_ERROR_LIB_RM_VERSION_MISMATCH: nvmlReturn_enum = 18;
pub const nvmlReturn_enum_NVML_ERROR_IN_USE: nvmlReturn_enum = 19;
pub const nvmlReturn_enum_NVML_ERROR_MEMORY: nvmlReturn_enum = 20;
pub const nvmlReturn_enum_NVML_ERROR_NO_DATA: nvmlReturn_enum = 21;
pub const nvmlReturn_enum_NVML_ERROR_VGPU_ECC_NOT_SUPPORTED: nvmlReturn_enum = 22;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_RESOURCES: nvmlReturn_enum = 23;
pub const nvmlReturn_enum_NVML_ERROR_FREQ_NOT_SUPPORTED: nvmlReturn_enum = 24;
pub const nvmlReturn_enum_NVML_ERROR_ARGUMENT_VERSION_MISMATCH: nvmlReturn_enum = 25;
pub const nvmlReturn_enum_NVML_ERROR_DEPRECATED: nvmlReturn_enum = 26;
pub const nvmlReturn_enum_NVML_ERROR_NOT_READY: nvmlReturn_enum = 27;
pub const nvmlReturn_enum_NVML_ERROR_UNKNOWN: nvmlReturn_enum = 999;
pub type nvmlReturn_enum = raw::c_uint;
pub use self::nvmlReturn_enum as nvmlReturn_t;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L1_CACHE: nvmlMemoryLocation_enum = 0;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L2_CACHE: nvmlMemoryLocation_enum = 1;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DRAM: nvmlMemoryLocation_enum = 2;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DEVICE_MEMORY: nvmlMemoryLocation_enum = 2;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_REGISTER_FILE: nvmlMemoryLocation_enum = 3;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_MEMORY: nvmlMemoryLocation_enum = 4;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_SHM: nvmlMemoryLocation_enum = 5;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_CBU: nvmlMemoryLocation_enum = 6;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_SRAM: nvmlMemoryLocation_enum = 7;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_COUNT: nvmlMemoryLocation_enum = 8;
pub type nvmlMemoryLocation_enum = raw::c_uint;
pub use self::nvmlMemoryLocation_enum as nvmlMemoryLocation_t;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS:
    nvmlPageRetirementCause_enum = 0;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR:
    nvmlPageRetirementCause_enum = 1;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_COUNT:
    nvmlPageRetirementCause_enum = 2;
pub type nvmlPageRetirementCause_enum = raw::c_uint;
pub use self::nvmlPageRetirementCause_enum as nvmlPageRetirementCause_t;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS:
    nvmlRestrictedAPI_enum = 0;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS:
    nvmlRestrictedAPI_enum = 1;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_COUNT: nvmlRestrictedAPI_enum = 2;
pub type nvmlRestrictedAPI_enum = raw::c_uint;
pub use self::nvmlRestrictedAPI_enum as nvmlRestrictedAPI_t;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_NONE: nvmlGpuVirtualizationMode =
    0;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH:
    nvmlGpuVirtualizationMode = 1;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_VGPU: nvmlGpuVirtualizationMode =
    2;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU:
    nvmlGpuVirtualizationMode = 3;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA:
    nvmlGpuVirtualizationMode = 4;
pub type nvmlGpuVirtualizationMode = raw::c_uint;
pub use self::nvmlGpuVirtualizationMode as nvmlGpuVirtualizationMode_t;
pub const nvmlHostVgpuMode_enum_NVML_HOST_VGPU_MODE_NON_SRIOV: nvmlHostVgpuMode_enum = 0;
pub const nvmlHostVgpuMode_enum_NVML_HOST_VGPU_MODE_SRIOV: nvmlHostVgpuMode_enum = 1;
pub type nvmlHostVgpuMode_enum = raw::c_uint;
pub use self::nvmlHostVgpuMode_enum as nvmlHostVgpuMode_t;
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_DOMAIN_ID: nvmlVgpuVmIdType = 0;
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_UUID: nvmlVgpuVmIdType = 1;
pub type nvmlVgpuVmIdType = raw::c_uint;
pub use self::nvmlVgpuVmIdType as nvmlVgpuVmIdType_t;
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED:
    nvmlVgpuGuestInfoState_enum = 0;
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED:
    nvmlVgpuGuestInfoState_enum = 1;
pub type nvmlVgpuGuestInfoState_enum = raw::c_uint;
pub use self::nvmlVgpuGuestInfoState_enum as nvmlVgpuGuestInfoState_t;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_UNKNOWN:
    nvmlGridLicenseFeatureCode_t = 0;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VGPU:
    nvmlGridLicenseFeatureCode_t = 1;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_NVIDIA_RTX:
    nvmlGridLicenseFeatureCode_t = 2;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION:
    nvmlGridLicenseFeatureCode_t = 2;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_GAMING:
    nvmlGridLicenseFeatureCode_t = 3;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_COMPUTE:
    nvmlGridLicenseFeatureCode_t = 4;
pub type nvmlGridLicenseFeatureCode_t = raw::c_uint;
pub const nvmlVgpuCapability_enum_NVML_VGPU_CAP_NVLINK_P2P: nvmlVgpuCapability_enum = 0;
pub const nvmlVgpuCapability_enum_NVML_VGPU_CAP_GPUDIRECT: nvmlVgpuCapability_enum = 1;
pub const nvmlVgpuCapability_enum_NVML_VGPU_CAP_MULTI_VGPU_EXCLUSIVE: nvmlVgpuCapability_enum = 2;
pub const nvmlVgpuCapability_enum_NVML_VGPU_CAP_EXCLUSIVE_TYPE: nvmlVgpuCapability_enum = 3;
pub const nvmlVgpuCapability_enum_NVML_VGPU_CAP_EXCLUSIVE_SIZE: nvmlVgpuCapability_enum = 4;
pub const nvmlVgpuCapability_enum_NVML_VGPU_CAP_COUNT: nvmlVgpuCapability_enum = 5;
pub type nvmlVgpuCapability_enum = raw::c_uint;
pub use self::nvmlVgpuCapability_enum as nvmlVgpuCapability_t;
pub const nvmlVgpuDriverCapability_enum_NVML_VGPU_DRIVER_CAP_HETEROGENEOUS_MULTI_VGPU:
    nvmlVgpuDriverCapability_enum = 0;
pub const nvmlVgpuDriverCapability_enum_NVML_VGPU_DRIVER_CAP_COUNT: nvmlVgpuDriverCapability_enum =
    1;
pub type nvmlVgpuDriverCapability_enum = raw::c_uint;
pub use self::nvmlVgpuDriverCapability_enum as nvmlVgpuDriverCapability_t;
pub const nvmlDeviceVgpuCapability_enum_NVML_DEVICE_VGPU_CAP_FRACTIONAL_MULTI_VGPU:
    nvmlDeviceVgpuCapability_enum = 0;
pub const nvmlDeviceVgpuCapability_enum_NVML_DEVICE_VGPU_CAP_HETEROGENEOUS_TIMESLICE_PROFILES:
    nvmlDeviceVgpuCapability_enum = 1;
pub const nvmlDeviceVgpuCapability_enum_NVML_DEVICE_VGPU_CAP_HETEROGENEOUS_TIMESLICE_SIZES:
    nvmlDeviceVgpuCapability_enum = 2;
pub const nvmlDeviceVgpuCapability_enum_NVML_DEVICE_VGPU_CAP_READ_DEVICE_BUFFER_BW:
    nvmlDeviceVgpuCapability_enum = 3;
pub const nvmlDeviceVgpuCapability_enum_NVML_DEVICE_VGPU_CAP_WRITE_DEVICE_BUFFER_BW:
    nvmlDeviceVgpuCapability_enum = 4;
pub const nvmlDeviceVgpuCapability_enum_NVML_DEVICE_VGPU_CAP_COUNT: nvmlDeviceVgpuCapability_enum =
    5;
pub type nvmlDeviceVgpuCapability_enum = raw::c_uint;
pub use self::nvmlDeviceVgpuCapability_enum as nvmlDeviceVgpuCapability_t;
pub type nvmlVgpuTypeId_t = raw::c_uint;
pub type nvmlVgpuInstance_t = raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuInstanceUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: nvmlValue_t,
    pub memUtil: nvmlValue_t,
    pub encUtil: nvmlValue_t,
    pub decUtil: nvmlValue_t,
}
pub type nvmlVgpuInstanceUtilizationSample_t = nvmlVgpuInstanceUtilizationSample_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuProcessUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub pid: raw::c_uint,
    pub processName: [raw::c_char; 64usize],
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: raw::c_uint,
    pub memUtil: raw::c_uint,
    pub encUtil: raw::c_uint,
    pub decUtil: raw::c_uint,
}
pub type nvmlVgpuProcessUtilizationSample_t = nvmlVgpuProcessUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlVgpuSchedulerParams_t {
    pub vgpuSchedDataWithARR: nvmlVgpuSchedulerParams_t__bindgen_ty_1,
    pub vgpuSchedData: nvmlVgpuSchedulerParams_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuSchedulerParams_t__bindgen_ty_1 {
    pub avgFactor: raw::c_uint,
    pub timeslice: raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuSchedulerParams_t__bindgen_ty_2 {
    pub timeslice: raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuSchedulerLogEntries_st {
    pub timestamp: raw::c_ulonglong,
    pub timeRunTotal: raw::c_ulonglong,
    pub timeRun: raw::c_ulonglong,
    pub swRunlistId: raw::c_uint,
    pub targetTimeSlice: raw::c_ulonglong,
    pub cumulativePreemptionTime: raw::c_ulonglong,
}
pub type nvmlVgpuSchedulerLogEntry_t = nvmlVgpuSchedulerLogEntries_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerLog_st {
    pub engineId: raw::c_uint,
    pub schedulerPolicy: raw::c_uint,
    pub arrMode: raw::c_uint,
    pub schedulerParams: nvmlVgpuSchedulerParams_t,
    pub entriesCount: raw::c_uint,
    pub logEntries: [nvmlVgpuSchedulerLogEntry_t; 200usize],
}
pub type nvmlVgpuSchedulerLog_t = nvmlVgpuSchedulerLog_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerGetState_st {
    pub schedulerPolicy: raw::c_uint,
    pub arrMode: raw::c_uint,
    pub schedulerParams: nvmlVgpuSchedulerParams_t,
}
pub type nvmlVgpuSchedulerGetState_t = nvmlVgpuSchedulerGetState_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlVgpuSchedulerSetParams_t {
    pub vgpuSchedDataWithARR: nvmlVgpuSchedulerSetParams_t__bindgen_ty_1,
    pub vgpuSchedData: nvmlVgpuSchedulerSetParams_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuSchedulerSetParams_t__bindgen_ty_1 {
    pub avgFactor: raw::c_uint,
    pub frequency: raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuSchedulerSetParams_t__bindgen_ty_2 {
    pub timeslice: raw::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuSchedulerSetState_st {
    pub schedulerPolicy: raw::c_uint,
    pub enableARRMode: raw::c_uint,
    pub schedulerParams: nvmlVgpuSchedulerSetParams_t,
}
pub type nvmlVgpuSchedulerSetState_t = nvmlVgpuSchedulerSetState_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuSchedulerCapabilities_st {
    pub supportedSchedulers: [raw::c_uint; 3usize],
    pub maxTimeslice: raw::c_uint,
    pub minTimeslice: raw::c_uint,
    pub isArrModeSupported: raw::c_uint,
    pub maxFrequencyForARR: raw::c_uint,
    pub minFrequencyForARR: raw::c_uint,
    pub maxAvgFactorForARR: raw::c_uint,
    pub minAvgFactorForARR: raw::c_uint,
}
pub type nvmlVgpuSchedulerCapabilities_t = nvmlVgpuSchedulerCapabilities_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuLicenseExpiry_st {
    pub year: raw::c_uint,
    pub month: raw::c_ushort,
    pub day: raw::c_ushort,
    pub hour: raw::c_ushort,
    pub min: raw::c_ushort,
    pub sec: raw::c_ushort,
    pub status: raw::c_uchar,
}
pub type nvmlVgpuLicenseExpiry_t = nvmlVgpuLicenseExpiry_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuLicenseInfo_st {
    pub isLicensed: raw::c_uchar,
    pub licenseExpiry: nvmlVgpuLicenseExpiry_t,
    pub currentState: raw::c_uint,
}
pub type nvmlVgpuLicenseInfo_t = nvmlVgpuLicenseInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessUtilizationSample_st {
    pub pid: raw::c_uint,
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: raw::c_uint,
    pub memUtil: raw::c_uint,
    pub encUtil: raw::c_uint,
    pub decUtil: raw::c_uint,
}
pub type nvmlProcessUtilizationSample_t = nvmlProcessUtilizationSample_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGridLicenseExpiry_st {
    pub year: raw::c_uint,
    pub month: raw::c_ushort,
    pub day: raw::c_ushort,
    pub hour: raw::c_ushort,
    pub min: raw::c_ushort,
    pub sec: raw::c_ushort,
    pub status: raw::c_uchar,
}
pub type nvmlGridLicenseExpiry_t = nvmlGridLicenseExpiry_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGridLicensableFeature_st {
    pub featureCode: nvmlGridLicenseFeatureCode_t,
    pub featureState: raw::c_uint,
    pub licenseInfo: [raw::c_char; 128usize],
    pub productName: [raw::c_char; 128usize],
    pub featureEnabled: raw::c_uint,
    pub licenseExpiry: nvmlGridLicenseExpiry_t,
}
pub type nvmlGridLicensableFeature_t = nvmlGridLicensableFeature_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGridLicensableFeatures_st {
    pub isGridLicenseSupported: raw::c_int,
    pub licensableFeaturesCount: raw::c_uint,
    pub gridLicensableFeatures: [nvmlGridLicensableFeature_t; 3usize],
}
pub type nvmlGridLicensableFeatures_t = nvmlGridLicensableFeatures_st;
pub type nvmlDeviceArchitecture_t = raw::c_uint;
pub type nvmlBusType_t = raw::c_uint;
pub type nvmlFanControlPolicy_t = raw::c_uint;
pub type nvmlPowerSource_t = raw::c_uint;
pub const nvmlGpuUtilizationDomainId_t_NVML_GPU_UTILIZATION_DOMAIN_GPU:
    nvmlGpuUtilizationDomainId_t = 0;
pub const nvmlGpuUtilizationDomainId_t_NVML_GPU_UTILIZATION_DOMAIN_FB:
    nvmlGpuUtilizationDomainId_t = 1;
pub const nvmlGpuUtilizationDomainId_t_NVML_GPU_UTILIZATION_DOMAIN_VID:
    nvmlGpuUtilizationDomainId_t = 2;
pub const nvmlGpuUtilizationDomainId_t_NVML_GPU_UTILIZATION_DOMAIN_BUS:
    nvmlGpuUtilizationDomainId_t = 3;
pub type nvmlGpuUtilizationDomainId_t = raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuDynamicPstatesInfo_st {
    pub flags: raw::c_uint,
    pub utilization: [nvmlGpuDynamicPstatesInfo_st__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuDynamicPstatesInfo_st__bindgen_ty_1 {
    pub bIsPresent: raw::c_uint,
    pub percentage: raw::c_uint,
    pub incThreshold: raw::c_uint,
    pub decThreshold: raw::c_uint,
}
pub type nvmlGpuDynamicPstatesInfo_t = nvmlGpuDynamicPstatesInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFieldValue_st {
    pub fieldId: raw::c_uint,
    pub scopeId: raw::c_uint,
    pub timestamp: raw::c_longlong,
    pub latencyUsec: raw::c_longlong,
    pub valueType: nvmlValueType_t,
    pub nvmlReturn: nvmlReturn_t,
    pub value: nvmlValue_t,
}
pub type nvmlFieldValue_t = nvmlFieldValue_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnit_st {
    _unused: [u8; 0],
}
pub type nvmlUnit_t = *mut nvmlUnit_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlHwbcEntry_st {
    pub hwbcId: raw::c_uint,
    pub firmwareVersion: [raw::c_char; 32usize],
}
pub type nvmlHwbcEntry_t = nvmlHwbcEntry_st;
pub const nvmlFanState_enum_NVML_FAN_NORMAL: nvmlFanState_enum = 0;
pub const nvmlFanState_enum_NVML_FAN_FAILED: nvmlFanState_enum = 1;
pub type nvmlFanState_enum = raw::c_uint;
pub use self::nvmlFanState_enum as nvmlFanState_t;
pub const nvmlLedColor_enum_NVML_LED_COLOR_GREEN: nvmlLedColor_enum = 0;
pub const nvmlLedColor_enum_NVML_LED_COLOR_AMBER: nvmlLedColor_enum = 1;
pub type nvmlLedColor_enum = raw::c_uint;
pub use self::nvmlLedColor_enum as nvmlLedColor_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlLedState_st {
    pub cause: [raw::c_char; 256usize],
    pub color: nvmlLedColor_t,
}
pub type nvmlLedState_t = nvmlLedState_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnitInfo_st {
    pub name: [raw::c_char; 96usize],
    pub id: [raw::c_char; 96usize],
    pub serial: [raw::c_char; 96usize],
    pub firmwareVersion: [raw::c_char; 96usize],
}
pub type nvmlUnitInfo_t = nvmlUnitInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlPSUInfo_st {
    pub state: [raw::c_char; 256usize],
    pub current: raw::c_uint,
    pub voltage: raw::c_uint,
    pub power: raw::c_uint,
}
pub type nvmlPSUInfo_t = nvmlPSUInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnitFanInfo_st {
    pub speed: raw::c_uint,
    pub state: nvmlFanState_t,
}
pub type nvmlUnitFanInfo_t = nvmlUnitFanInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnitFanSpeeds_st {
    pub fans: [nvmlUnitFanInfo_t; 24usize],
    pub count: raw::c_uint,
}
pub type nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEventSet_st {
    _unused: [u8; 0],
}
pub type nvmlEventSet_t = *mut nvmlEventSet_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEventData_st {
    pub device: nvmlDevice_t,
    pub eventType: raw::c_ulonglong,
    pub eventData: raw::c_ulonglong,
    pub gpuInstanceId: raw::c_uint,
    pub computeInstanceId: raw::c_uint,
}
pub type nvmlEventData_t = nvmlEventData_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlAccountingStats_st {
    pub gpuUtilization: raw::c_uint,
    pub memoryUtilization: raw::c_uint,
    pub maxMemoryUsage: raw::c_ulonglong,
    pub time: raw::c_ulonglong,
    pub startTime: raw::c_ulonglong,
    pub isRunning: raw::c_uint,
    pub reserved: [raw::c_uint; 5usize],
}
pub type nvmlAccountingStats_t = nvmlAccountingStats_st;
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_H264: nvmlEncoderQueryType_enum = 0;
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_HEVC: nvmlEncoderQueryType_enum = 1;
pub type nvmlEncoderQueryType_enum = raw::c_uint;
pub use self::nvmlEncoderQueryType_enum as nvmlEncoderType_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEncoderSessionInfo_st {
    pub sessionId: raw::c_uint,
    pub pid: raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub codecType: nvmlEncoderType_t,
    pub hResolution: raw::c_uint,
    pub vResolution: raw::c_uint,
    pub averageFps: raw::c_uint,
    pub averageLatency: raw::c_uint,
}
pub type nvmlEncoderSessionInfo_t = nvmlEncoderSessionInfo_st;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_UNKNOWN: nvmlFBCSessionType_enum = 0;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_TOSYS: nvmlFBCSessionType_enum = 1;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_CUDA: nvmlFBCSessionType_enum = 2;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_VID: nvmlFBCSessionType_enum = 3;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_HWENC: nvmlFBCSessionType_enum = 4;
pub type nvmlFBCSessionType_enum = raw::c_uint;
pub use self::nvmlFBCSessionType_enum as nvmlFBCSessionType_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlFBCStats_st {
    pub sessionsCount: raw::c_uint,
    pub averageFPS: raw::c_uint,
    pub averageLatency: raw::c_uint,
}
pub type nvmlFBCStats_t = nvmlFBCStats_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlFBCSessionInfo_st {
    pub sessionId: raw::c_uint,
    pub pid: raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub displayOrdinal: raw::c_uint,
    pub sessionType: nvmlFBCSessionType_t,
    pub sessionFlags: raw::c_uint,
    pub hMaxResolution: raw::c_uint,
    pub vMaxResolution: raw::c_uint,
    pub hResolution: raw::c_uint,
    pub vResolution: raw::c_uint,
    pub averageFPS: raw::c_uint,
    pub averageLatency: raw::c_uint,
}
pub type nvmlFBCSessionInfo_t = nvmlFBCSessionInfo_st;
pub const nvmlDetachGpuState_enum_NVML_DETACH_GPU_KEEP: nvmlDetachGpuState_enum = 0;
pub const nvmlDetachGpuState_enum_NVML_DETACH_GPU_REMOVE: nvmlDetachGpuState_enum = 1;
pub type nvmlDetachGpuState_enum = raw::c_uint;
pub use self::nvmlDetachGpuState_enum as nvmlDetachGpuState_t;
pub const nvmlPcieLinkState_enum_NVML_PCIE_LINK_KEEP: nvmlPcieLinkState_enum = 0;
pub const nvmlPcieLinkState_enum_NVML_PCIE_LINK_SHUT_DOWN: nvmlPcieLinkState_enum = 1;
pub type nvmlPcieLinkState_enum = raw::c_uint;
pub use self::nvmlPcieLinkState_enum as nvmlPcieLinkState_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlConfComputeSystemCaps_st {
    pub cpuCaps: raw::c_uint,
    pub gpusCaps: raw::c_uint,
}
pub type nvmlConfComputeSystemCaps_t = nvmlConfComputeSystemCaps_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlConfComputeSystemState_st {
    pub environment: raw::c_uint,
    pub ccFeature: raw::c_uint,
    pub devToolsMode: raw::c_uint,
}
pub type nvmlConfComputeSystemState_t = nvmlConfComputeSystemState_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlConfComputeMemSizeInfo_st {
    pub protectedMemSizeKib: raw::c_ulonglong,
    pub unprotectedMemSizeKib: raw::c_ulonglong,
}
pub type nvmlConfComputeMemSizeInfo_t = nvmlConfComputeMemSizeInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlConfComputeGpuCertificate_st {
    pub certChainSize: raw::c_uint,
    pub attestationCertChainSize: raw::c_uint,
    pub certChain: [raw::c_uchar; 4096usize],
    pub attestationCertChain: [raw::c_uchar; 5120usize],
}
pub type nvmlConfComputeGpuCertificate_t = nvmlConfComputeGpuCertificate_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlConfComputeGpuAttestationReport_st {
    pub isCecAttestationReportPresent: raw::c_uint,
    pub attestationReportSize: raw::c_uint,
    pub cecAttestationReportSize: raw::c_uint,
    pub nonce: [raw::c_uchar; 32usize],
    pub attestationReport: [raw::c_uchar; 8192usize],
    pub cecAttestationReport: [raw::c_uchar; 4096usize],
}
pub type nvmlConfComputeGpuAttestationReport_t = nvmlConfComputeGpuAttestationReport_st;
pub type nvmlGpuFabricState_t = raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuFabricInfo_t {
    pub clusterUuid: [raw::c_char; 16usize],
    pub status: nvmlReturn_t,
    pub partitionId: raw::c_uint,
    pub state: nvmlGpuFabricState_t,
}
pub type nvmlPowerScopeType_t = raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlPowerValue_v2_t {
    pub version: raw::c_uint,
    pub powerScope: nvmlPowerScopeType_t,
    pub powerValueMw: raw::c_uint,
}
pub type nvmlAffinityScope_t = raw::c_uint;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_RANGE_START: nvmlClockLimitId_enum = 4294967040;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_TDP: nvmlClockLimitId_enum = 4294967041;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_UNLIMITED: nvmlClockLimitId_enum = 4294967042;
pub type nvmlClockLimitId_enum = raw::c_uint;
pub use self::nvmlClockLimitId_enum as nvmlClockLimitId_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuVersion_st {
    pub minVersion: raw::c_uint,
    pub maxVersion: raw::c_uint,
}
pub type nvmlVgpuVersion_t = nvmlVgpuVersion_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuMetadata_st {
    pub version: raw::c_uint,
    pub revision: raw::c_uint,
    pub guestInfoState: nvmlVgpuGuestInfoState_t,
    pub guestDriverVersion: [raw::c_char; 80usize],
    pub hostDriverVersion: [raw::c_char; 80usize],
    pub reserved: [raw::c_uint; 6usize],
    pub vgpuVirtualizationCaps: raw::c_uint,
    pub guestVgpuVersion: raw::c_uint,
    pub opaqueDataSize: raw::c_uint,
    pub opaqueData: [raw::c_char; 4usize],
}
pub type nvmlVgpuMetadata_t = nvmlVgpuMetadata_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuPgpuMetadata_st {
    pub version: raw::c_uint,
    pub revision: raw::c_uint,
    pub hostDriverVersion: [raw::c_char; 80usize],
    pub pgpuVirtualizationCaps: raw::c_uint,
    pub reserved: [raw::c_uint; 5usize],
    pub hostSupportedVgpuRange: nvmlVgpuVersion_t,
    pub opaqueDataSize: raw::c_uint,
    pub opaqueData: [raw::c_char; 4usize],
}
pub type nvmlVgpuPgpuMetadata_t = nvmlVgpuPgpuMetadata_st;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_NONE:
    nvmlVgpuVmCompatibility_enum = 0;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_COLD:
    nvmlVgpuVmCompatibility_enum = 1;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_HIBERNATE:
    nvmlVgpuVmCompatibility_enum = 2;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_SLEEP:
    nvmlVgpuVmCompatibility_enum = 4;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_LIVE:
    nvmlVgpuVmCompatibility_enum = 8;
pub type nvmlVgpuVmCompatibility_enum = raw::c_uint;
pub use self::nvmlVgpuVmCompatibility_enum as nvmlVgpuVmCompatibility_t;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_NONE:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 0;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 1;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 2;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_GPU:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 4;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_OTHER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 2147483648;
pub type nvmlVgpuPgpuCompatibilityLimitCode_enum = raw::c_uint;
pub use self::nvmlVgpuPgpuCompatibilityLimitCode_enum as nvmlVgpuPgpuCompatibilityLimitCode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuPgpuCompatibility_st {
    pub vgpuVmCompatibility: nvmlVgpuVmCompatibility_t,
    pub compatibilityLimitCode: nvmlVgpuPgpuCompatibilityLimitCode_t,
}
pub type nvmlVgpuPgpuCompatibility_t = nvmlVgpuPgpuCompatibility_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlExcludedDeviceInfo_st {
    pub pciInfo: nvmlPciInfo_t,
    pub uuid: [raw::c_char; 80usize],
}
pub type nvmlExcludedDeviceInfo_t = nvmlExcludedDeviceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstancePlacement_st {
    pub start: raw::c_uint,
    pub size: raw::c_uint,
}
pub type nvmlGpuInstancePlacement_t = nvmlGpuInstancePlacement_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstanceProfileInfo_st {
    pub id: raw::c_uint,
    pub isP2pSupported: raw::c_uint,
    pub sliceCount: raw::c_uint,
    pub instanceCount: raw::c_uint,
    pub multiprocessorCount: raw::c_uint,
    pub copyEngineCount: raw::c_uint,
    pub decoderCount: raw::c_uint,
    pub encoderCount: raw::c_uint,
    pub jpegCount: raw::c_uint,
    pub ofaCount: raw::c_uint,
    pub memorySizeMB: raw::c_ulonglong,
}
pub type nvmlGpuInstanceProfileInfo_t = nvmlGpuInstanceProfileInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstanceProfileInfo_v2_st {
    pub version: raw::c_uint,
    pub id: raw::c_uint,
    pub isP2pSupported: raw::c_uint,
    pub sliceCount: raw::c_uint,
    pub instanceCount: raw::c_uint,
    pub multiprocessorCount: raw::c_uint,
    pub copyEngineCount: raw::c_uint,
    pub decoderCount: raw::c_uint,
    pub encoderCount: raw::c_uint,
    pub jpegCount: raw::c_uint,
    pub ofaCount: raw::c_uint,
    pub memorySizeMB: raw::c_ulonglong,
    pub name: [raw::c_char; 96usize],
}
pub type nvmlGpuInstanceProfileInfo_v2_t = nvmlGpuInstanceProfileInfo_v2_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstanceInfo_st {
    pub device: nvmlDevice_t,
    pub id: raw::c_uint,
    pub profileId: raw::c_uint,
    pub placement: nvmlGpuInstancePlacement_t,
}
pub type nvmlGpuInstanceInfo_t = nvmlGpuInstanceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstance_st {
    _unused: [u8; 0],
}
pub type nvmlGpuInstance_t = *mut nvmlGpuInstance_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstancePlacement_st {
    pub start: raw::c_uint,
    pub size: raw::c_uint,
}
pub type nvmlComputeInstancePlacement_t = nvmlComputeInstancePlacement_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstanceProfileInfo_st {
    pub id: raw::c_uint,
    pub sliceCount: raw::c_uint,
    pub instanceCount: raw::c_uint,
    pub multiprocessorCount: raw::c_uint,
    pub sharedCopyEngineCount: raw::c_uint,
    pub sharedDecoderCount: raw::c_uint,
    pub sharedEncoderCount: raw::c_uint,
    pub sharedJpegCount: raw::c_uint,
    pub sharedOfaCount: raw::c_uint,
}
pub type nvmlComputeInstanceProfileInfo_t = nvmlComputeInstanceProfileInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstanceProfileInfo_v2_st {
    pub version: raw::c_uint,
    pub id: raw::c_uint,
    pub sliceCount: raw::c_uint,
    pub instanceCount: raw::c_uint,
    pub multiprocessorCount: raw::c_uint,
    pub sharedCopyEngineCount: raw::c_uint,
    pub sharedDecoderCount: raw::c_uint,
    pub sharedEncoderCount: raw::c_uint,
    pub sharedJpegCount: raw::c_uint,
    pub sharedOfaCount: raw::c_uint,
    pub name: [raw::c_char; 96usize],
}
pub type nvmlComputeInstanceProfileInfo_v2_t = nvmlComputeInstanceProfileInfo_v2_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstanceInfo_st {
    pub device: nvmlDevice_t,
    pub gpuInstance: nvmlGpuInstance_t,
    pub id: raw::c_uint,
    pub profileId: raw::c_uint,
    pub placement: nvmlComputeInstancePlacement_t,
}
pub type nvmlComputeInstanceInfo_t = nvmlComputeInstanceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstance_st {
    _unused: [u8; 0],
}
pub type nvmlComputeInstance_t = *mut nvmlComputeInstance_st;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_GRAPHICS_UTIL: nvmlGpmMetricId_t = 1;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_SM_UTIL: nvmlGpmMetricId_t = 2;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_SM_OCCUPANCY: nvmlGpmMetricId_t = 3;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_INTEGER_UTIL: nvmlGpmMetricId_t = 4;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_ANY_TENSOR_UTIL: nvmlGpmMetricId_t = 5;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_DFMA_TENSOR_UTIL: nvmlGpmMetricId_t = 6;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_HMMA_TENSOR_UTIL: nvmlGpmMetricId_t = 7;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_IMMA_TENSOR_UTIL: nvmlGpmMetricId_t = 9;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_DRAM_BW_UTIL: nvmlGpmMetricId_t = 10;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_FP64_UTIL: nvmlGpmMetricId_t = 11;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_FP32_UTIL: nvmlGpmMetricId_t = 12;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_FP16_UTIL: nvmlGpmMetricId_t = 13;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_PCIE_TX_PER_SEC: nvmlGpmMetricId_t = 20;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_PCIE_RX_PER_SEC: nvmlGpmMetricId_t = 21;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_0_UTIL: nvmlGpmMetricId_t = 30;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_1_UTIL: nvmlGpmMetricId_t = 31;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_2_UTIL: nvmlGpmMetricId_t = 32;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_3_UTIL: nvmlGpmMetricId_t = 33;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_4_UTIL: nvmlGpmMetricId_t = 34;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_5_UTIL: nvmlGpmMetricId_t = 35;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_6_UTIL: nvmlGpmMetricId_t = 36;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVDEC_7_UTIL: nvmlGpmMetricId_t = 37;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_0_UTIL: nvmlGpmMetricId_t = 40;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_1_UTIL: nvmlGpmMetricId_t = 41;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_2_UTIL: nvmlGpmMetricId_t = 42;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_3_UTIL: nvmlGpmMetricId_t = 43;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_4_UTIL: nvmlGpmMetricId_t = 44;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_5_UTIL: nvmlGpmMetricId_t = 45;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_6_UTIL: nvmlGpmMetricId_t = 46;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVJPG_7_UTIL: nvmlGpmMetricId_t = 47;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVOFA_0_UTIL: nvmlGpmMetricId_t = 50;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_TOTAL_RX_PER_SEC: nvmlGpmMetricId_t = 60;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_TOTAL_TX_PER_SEC: nvmlGpmMetricId_t = 61;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L0_RX_PER_SEC: nvmlGpmMetricId_t = 62;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L0_TX_PER_SEC: nvmlGpmMetricId_t = 63;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L1_RX_PER_SEC: nvmlGpmMetricId_t = 64;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L1_TX_PER_SEC: nvmlGpmMetricId_t = 65;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L2_RX_PER_SEC: nvmlGpmMetricId_t = 66;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L2_TX_PER_SEC: nvmlGpmMetricId_t = 67;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L3_RX_PER_SEC: nvmlGpmMetricId_t = 68;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L3_TX_PER_SEC: nvmlGpmMetricId_t = 69;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L4_RX_PER_SEC: nvmlGpmMetricId_t = 70;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L4_TX_PER_SEC: nvmlGpmMetricId_t = 71;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L5_RX_PER_SEC: nvmlGpmMetricId_t = 72;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L5_TX_PER_SEC: nvmlGpmMetricId_t = 73;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L6_RX_PER_SEC: nvmlGpmMetricId_t = 74;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L6_TX_PER_SEC: nvmlGpmMetricId_t = 75;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L7_RX_PER_SEC: nvmlGpmMetricId_t = 76;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L7_TX_PER_SEC: nvmlGpmMetricId_t = 77;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L8_RX_PER_SEC: nvmlGpmMetricId_t = 78;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L8_TX_PER_SEC: nvmlGpmMetricId_t = 79;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L9_RX_PER_SEC: nvmlGpmMetricId_t = 80;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L9_TX_PER_SEC: nvmlGpmMetricId_t = 81;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L10_RX_PER_SEC: nvmlGpmMetricId_t = 82;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L10_TX_PER_SEC: nvmlGpmMetricId_t = 83;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L11_RX_PER_SEC: nvmlGpmMetricId_t = 84;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L11_TX_PER_SEC: nvmlGpmMetricId_t = 85;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L12_RX_PER_SEC: nvmlGpmMetricId_t = 86;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L12_TX_PER_SEC: nvmlGpmMetricId_t = 87;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L13_RX_PER_SEC: nvmlGpmMetricId_t = 88;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L13_TX_PER_SEC: nvmlGpmMetricId_t = 89;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L14_RX_PER_SEC: nvmlGpmMetricId_t = 90;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L14_TX_PER_SEC: nvmlGpmMetricId_t = 91;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L15_RX_PER_SEC: nvmlGpmMetricId_t = 92;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L15_TX_PER_SEC: nvmlGpmMetricId_t = 93;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L16_RX_PER_SEC: nvmlGpmMetricId_t = 94;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L16_TX_PER_SEC: nvmlGpmMetricId_t = 95;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L17_RX_PER_SEC: nvmlGpmMetricId_t = 96;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_NVLINK_L17_TX_PER_SEC: nvmlGpmMetricId_t = 97;
pub const nvmlGpmMetricId_t_NVML_GPM_METRIC_MAX: nvmlGpmMetricId_t = 98;
pub type nvmlGpmMetricId_t = raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpmSample_st {
    _unused: [u8; 0],
}
pub type nvmlGpmSample_t = *mut nvmlGpmSample_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpmMetric_t {
    pub metricId: raw::c_uint,
    pub nvmlReturn: nvmlReturn_t,
    pub value: f64,
    pub metricInfo: nvmlGpmMetric_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpmMetric_t__bindgen_ty_1 {
    pub shortName: *mut raw::c_char,
    pub longName: *mut raw::c_char,
    pub unit: *mut raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpmMetricsGet_t {
    pub version: raw::c_uint,
    pub numMetrics: raw::c_uint,
    pub sample1: nvmlGpmSample_t,
    pub sample2: nvmlGpmSample_t,
    pub metrics: [nvmlGpmMetric_t; 98usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpmSupport_t {
    pub version: raw::c_uint,
    pub isSupportedDevice: raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlNvLinkPowerThres_st {
    pub lowPwrThreshold: raw::c_uint,
}
pub type nvmlNvLinkPowerThres_t = nvmlNvLinkPowerThres_st;
extern crate libloading;
pub struct NvmlLib {
    pub __library: ::libloading::Library,
    pub nvmlInit_v2: Result<unsafe extern "C" fn() -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlInitWithFlags:
        Result<unsafe extern "C" fn(flags: raw::c_uint) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlShutdown: Result<unsafe extern "C" fn() -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlErrorString: Result<
        unsafe extern "C" fn(result: nvmlReturn_t) -> *const raw::c_char,
        ::libloading::Error,
    >,
    pub nvmlSystemGetDriverVersion: Result<
        unsafe extern "C" fn(version: *mut raw::c_char, length: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetNVMLVersion: Result<
        unsafe extern "C" fn(version: *mut raw::c_char, length: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetCudaDriverVersion: Result<
        unsafe extern "C" fn(cudaDriverVersion: *mut raw::c_int) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetCudaDriverVersion_v2: Result<
        unsafe extern "C" fn(cudaDriverVersion: *mut raw::c_int) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetProcessName: Result<
        unsafe extern "C" fn(
            pid: raw::c_uint,
            name: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetCount: Result<
        unsafe extern "C" fn(unitCount: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetHandleByIndex: Result<
        unsafe extern "C" fn(index: raw::c_uint, unit: *mut nvmlUnit_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetUnitInfo: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, info: *mut nvmlUnitInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetLedState: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, state: *mut nvmlLedState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetPsuInfo: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, psu: *mut nvmlPSUInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetTemperature: Result<
        unsafe extern "C" fn(
            unit: nvmlUnit_t,
            type_: raw::c_uint,
            temp: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetFanSpeedInfo: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, fanSpeeds: *mut nvmlUnitFanSpeeds_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetDevices: Result<
        unsafe extern "C" fn(
            unit: nvmlUnit_t,
            deviceCount: *mut raw::c_uint,
            devices: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetHicVersion: Result<
        unsafe extern "C" fn(
            hwbcCount: *mut raw::c_uint,
            hwbcEntries: *mut nvmlHwbcEntry_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCount_v2: Result<
        unsafe extern "C" fn(deviceCount: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAttributes_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            attributes: *mut nvmlDeviceAttributes_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleByIndex_v2: Result<
        unsafe extern "C" fn(index: raw::c_uint, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleBySerial: Result<
        unsafe extern "C" fn(serial: *const raw::c_char, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleByUUID: Result<
        unsafe extern "C" fn(uuid: *const raw::c_char, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleByPciBusId_v2: Result<
        unsafe extern "C" fn(
            pciBusId: *const raw::c_char,
            device: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetName: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            name: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBrand: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, type_: *mut nvmlBrandType_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetIndex: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, index: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSerial: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            serial: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetModuleId: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, moduleId: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryAffinity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            nodeSetSize: raw::c_uint,
            nodeSet: *mut raw::c_ulong,
            scope: nvmlAffinityScope_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCpuAffinityWithinScope: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cpuSetSize: raw::c_uint,
            cpuSet: *mut raw::c_ulong,
            scope: nvmlAffinityScope_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCpuAffinity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cpuSetSize: raw::c_uint,
            cpuSet: *mut raw::c_ulong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetCpuAffinity:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceClearCpuAffinity:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetTopologyCommonAncestor: Result<
        unsafe extern "C" fn(
            device1: nvmlDevice_t,
            device2: nvmlDevice_t,
            pathInfo: *mut nvmlGpuTopologyLevel_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTopologyNearestGpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            level: nvmlGpuTopologyLevel_t,
            count: *mut raw::c_uint,
            deviceArray: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetTopologyGpuSet: Result<
        unsafe extern "C" fn(
            cpuNumber: raw::c_uint,
            count: *mut raw::c_uint,
            deviceArray: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetP2PStatus: Result<
        unsafe extern "C" fn(
            device1: nvmlDevice_t,
            device2: nvmlDevice_t,
            p2pIndex: nvmlGpuP2PCapsIndex_t,
            p2pStatus: *mut nvmlGpuP2PStatus_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetUUID: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            uuid: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetMdevUUID: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            mdevUuid: *mut raw::c_char,
            size: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMinorNumber: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, minorNumber: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBoardPartNumber: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            partNumber: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetInforomVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            object: nvmlInforomObject_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetInforomImageVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetInforomConfigurationChecksum: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, checksum: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceValidateInforom:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetDisplayMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, display: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDisplayActive: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            isActive: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPersistenceMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPciInfo_v3: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pci: *mut nvmlPciInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxPcieLinkGeneration: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, maxLinkGen: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuMaxPcieLinkGeneration: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            maxLinkGenDevice: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxPcieLinkWidth: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, maxLinkWidth: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCurrPcieLinkGeneration: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, currLinkGen: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCurrPcieLinkWidth: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, currLinkWidth: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPcieThroughput: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            counter: nvmlPcieUtilCounter_t,
            value: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPcieReplayCounter: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, value: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetClockInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            type_: nvmlClockType_t,
            clock: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxClockInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            type_: nvmlClockType_t,
            clock: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpcClkVfOffset: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, offset: *mut raw::c_int) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetApplicationsClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDefaultApplicationsClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetApplicationsClocks:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockId: nvmlClockId_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxCustomerBoostClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedMemoryClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            count: *mut raw::c_uint,
            clocksMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedGraphicsClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            memoryClockMHz: raw::c_uint,
            count: *mut raw::c_uint,
            clocksMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAutoBoostedClocksEnabled: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            isEnabled: *mut nvmlEnableState_t,
            defaultIsEnabled: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetAutoBoostedClocksEnabled: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, enabled: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetDefaultAutoBoostedClocksEnabled: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            enabled: nvmlEnableState_t,
            flags: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFanSpeed: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, speed: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFanSpeed_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            fan: raw::c_uint,
            speed: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTargetFanSpeed: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            fan: raw::c_uint,
            targetSpeed: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetDefaultFanSpeed_v2: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, fan: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMinMaxFanSpeed: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            minSpeed: *mut raw::c_uint,
            maxSpeed: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFanControlPolicy_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            fan: raw::c_uint,
            policy: *mut nvmlFanControlPolicy_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetFanControlPolicy: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            fan: raw::c_uint,
            policy: nvmlFanControlPolicy_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNumFans: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, numFans: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTemperature: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sensorType: nvmlTemperatureSensors_t,
            temp: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTemperatureThreshold: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            thresholdType: nvmlTemperatureThresholds_t,
            temp: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetTemperatureThreshold: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            thresholdType: nvmlTemperatureThresholds_t,
            temp: *mut raw::c_int,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetThermalSettings: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sensorIndex: raw::c_uint,
            pThermalSettings: *mut nvmlGpuThermalSettings_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPerformanceState: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pState: *mut nvmlPstates_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCurrentClocksEventReasons: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clocksEventReasons: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCurrentClocksThrottleReasons: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clocksThrottleReasons: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedClocksEventReasons: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            supportedClocksEventReasons: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedClocksThrottleReasons: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            supportedClocksThrottleReasons: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerState: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pState: *mut nvmlPstates_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDynamicPstatesInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pDynamicPstatesInfo: *mut nvmlGpuDynamicPstatesInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemClkVfOffset: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, offset: *mut raw::c_int) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMinMaxClockOfPState: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            type_: nvmlClockType_t,
            pstate: nvmlPstates_t,
            minClockMHz: *mut raw::c_uint,
            maxClockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedPerformanceStates: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pstates: *mut nvmlPstates_t,
            size: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpcClkMinMaxVfOffset: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            minOffset: *mut raw::c_int,
            maxOffset: *mut raw::c_int,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemClkMinMaxVfOffset: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            minOffset: *mut raw::c_int,
            maxOffset: *mut raw::c_int,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, limit: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementLimitConstraints: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            minLimit: *mut raw::c_uint,
            maxLimit: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementDefaultLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, defaultLimit: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerUsage: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, power: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTotalEnergyConsumption: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, energy: *mut raw::c_ulonglong) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEnforcedPowerLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, limit: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuOperationMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            current: *mut nvmlGpuOperationMode_t,
            pending: *mut nvmlGpuOperationMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryInfo: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, memory: *mut nvmlMemory_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryInfo_v2: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, memory: *mut nvmlMemory_v2_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetComputeMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlComputeMode_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCudaComputeCapability: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            major: *mut raw::c_int,
            minor: *mut raw::c_int,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEccMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            current: *mut nvmlEnableState_t,
            pending: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDefaultEccMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            defaultMode: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBoardId: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, boardId: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMultiGpuBoard: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, multiGpuBool: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTotalEccErrors: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            errorType: nvmlMemoryErrorType_t,
            counterType: nvmlEccCounterType_t,
            eccCounts: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDetailedEccErrors: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            errorType: nvmlMemoryErrorType_t,
            counterType: nvmlEccCounterType_t,
            eccCounts: *mut nvmlEccErrorCounts_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryErrorCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            errorType: nvmlMemoryErrorType_t,
            counterType: nvmlEccCounterType_t,
            locationType: nvmlMemoryLocation_t,
            count: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetUtilizationRates: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut nvmlUtilization_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut raw::c_uint,
            samplingPeriodUs: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderCapacity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            encoderQueryType: nvmlEncoderType_t,
            encoderCapacity: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderStats: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sessionCount: *mut raw::c_uint,
            averageFps: *mut raw::c_uint,
            averageLatency: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderSessions: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sessionCount: *mut raw::c_uint,
            sessionInfos: *mut nvmlEncoderSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDecoderUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut raw::c_uint,
            samplingPeriodUs: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetJpgUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut raw::c_uint,
            samplingPeriodUs: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetOfaUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut raw::c_uint,
            samplingPeriodUs: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFBCStats: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, fbcStats: *mut nvmlFBCStats_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFBCSessions: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sessionCount: *mut raw::c_uint,
            sessionInfo: *mut nvmlFBCSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDriverModel: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            current: *mut nvmlDriverModel_t,
            pending: *mut nvmlDriverModel_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVbiosVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBridgeChipInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            bridgeHierarchy: *mut nvmlBridgeChipHierarchy_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetComputeRunningProcesses_v3: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGraphicsRunningProcesses_v3: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMPSComputeRunningProcesses_v3: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRunningProcessDetailList: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            plist: *mut nvmlProcessDetailList_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceOnSameBoard: Result<
        unsafe extern "C" fn(
            device1: nvmlDevice_t,
            device2: nvmlDevice_t,
            onSameBoard: *mut raw::c_int,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAPIRestriction: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            apiType: nvmlRestrictedAPI_t,
            isRestricted: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSamples: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            type_: nvmlSamplingType_t,
            lastSeenTimeStamp: raw::c_ulonglong,
            sampleValType: *mut nvmlValueType_t,
            sampleCount: *mut raw::c_uint,
            samples: *mut nvmlSample_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBAR1MemoryInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            bar1Memory: *mut nvmlBAR1Memory_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetViolationStatus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            perfPolicyType: nvmlPerfPolicyType_t,
            violTime: *mut nvmlViolationTime_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetIrqNum: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, irqNum: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNumGpuCores: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, numCores: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerSource: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            powerSource: *mut nvmlPowerSource_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryBusWidth: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, busWidth: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPcieLinkMaxSpeed: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, maxSpeed: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPcieSpeed: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pcieSpeed: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAdaptiveClockInfoStatus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            adaptiveClockStatus: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBusType: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, type_: *mut nvmlBusType_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuFabricInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            gpuFabricInfo: *mut nvmlGpuFabricInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetConfComputeCapabilities: Result<
        unsafe extern "C" fn(capabilities: *mut nvmlConfComputeSystemCaps_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetConfComputeState: Result<
        unsafe extern "C" fn(state: *mut nvmlConfComputeSystemState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetConfComputeMemSizeInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            memInfo: *mut nvmlConfComputeMemSizeInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetConfComputeGpusReadyState: Result<
        unsafe extern "C" fn(isAcceptingWork: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetConfComputeProtectedMemoryUsage: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, memory: *mut nvmlMemory_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetConfComputeGpuCertificate: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            gpuCert: *mut nvmlConfComputeGpuCertificate_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetConfComputeGpuAttestationReport: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            gpuAtstReport: *mut nvmlConfComputeGpuAttestationReport_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingStats: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pid: raw::c_uint,
            stats: *mut nvmlAccountingStats_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingPids: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            count: *mut raw::c_uint,
            pids: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingBufferSize: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, bufferSize: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRetiredPages: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cause: nvmlPageRetirementCause_t,
            pageCount: *mut raw::c_uint,
            addresses: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRetiredPages_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cause: nvmlPageRetirementCause_t,
            pageCount: *mut raw::c_uint,
            addresses: *mut raw::c_ulonglong,
            timestamps: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRetiredPagesPendingStatus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            isPending: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRemappedRows: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            corrRows: *mut raw::c_uint,
            uncRows: *mut raw::c_uint,
            isPending: *mut raw::c_uint,
            failureOccurred: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRowRemapperHistogram: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            values: *mut nvmlRowRemapperHistogramValues_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetArchitecture: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            arch: *mut nvmlDeviceArchitecture_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitSetLedState: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, color: nvmlLedColor_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetPersistenceMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetComputeMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlComputeMode_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetEccMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, ecc: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceClearEccErrorCounts: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            counterType: nvmlEccCounterType_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetDriverModel: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            driverModel: nvmlDriverModel_t,
            flags: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetGpuLockedClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            minGpuClockMHz: raw::c_uint,
            maxGpuClockMHz: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetGpuLockedClocks:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceSetMemoryLockedClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            minMemClockMHz: raw::c_uint,
            maxMemClockMHz: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetMemoryLockedClocks:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceSetApplicationsClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            memClockMHz: raw::c_uint,
            graphicsClockMHz: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetClkMonStatus: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, status: *mut nvmlClkMonStatus_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetPowerManagementLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, limit: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetGpuOperationMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlGpuOperationMode_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetAPIRestriction: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            apiType: nvmlRestrictedAPI_t,
            isRestricted: nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetFanSpeed_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            fan: raw::c_uint,
            speed: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetGpcClkVfOffset: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, offset: raw::c_int) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetMemClkVfOffset: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, offset: raw::c_int) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetConfComputeUnprotectedMemSize: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, sizeKiB: raw::c_ulonglong) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemSetConfComputeGpusReadyState: Result<
        unsafe extern "C" fn(isAcceptingWork: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetAccountingMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceClearAccountingPids:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetNvLinkState: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            isActive: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            version: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkCapability: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            capability: nvmlNvLinkCapability_t,
            capResult: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkRemotePciInfo_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            pci: *mut nvmlPciInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkErrorCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: nvmlNvLinkErrorCounter_t,
            counterValue: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetNvLinkErrorCounters: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, link: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetNvLinkUtilizationControl: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            control: *mut nvmlNvLinkUtilizationControl_t,
            reset: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkUtilizationControl: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            control: *mut nvmlNvLinkUtilizationControl_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkUtilizationCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            rxcounter: *mut raw::c_ulonglong,
            txcounter: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceFreezeNvLinkUtilizationCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            freeze: nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetNvLinkUtilizationCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkRemoteDeviceType: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            pNvLinkDeviceType: *mut nvmlIntNvLinkDeviceType_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlEventSetCreate:
        Result<unsafe extern "C" fn(set: *mut nvmlEventSet_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceRegisterEvents: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            eventTypes: raw::c_ulonglong,
            set: nvmlEventSet_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedEventTypes: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            eventTypes: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlEventSetWait_v2: Result<
        unsafe extern "C" fn(
            set: nvmlEventSet_t,
            data: *mut nvmlEventData_t,
            timeoutms: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlEventSetFree:
        Result<unsafe extern "C" fn(set: nvmlEventSet_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceModifyDrainState: Result<
        unsafe extern "C" fn(
            pciInfo: *mut nvmlPciInfo_t,
            newState: nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceQueryDrainState: Result<
        unsafe extern "C" fn(
            pciInfo: *mut nvmlPciInfo_t,
            currentState: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceRemoveGpu_v2: Result<
        unsafe extern "C" fn(
            pciInfo: *mut nvmlPciInfo_t,
            gpuState: nvmlDetachGpuState_t,
            linkState: nvmlPcieLinkState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceDiscoverGpus: Result<
        unsafe extern "C" fn(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFieldValues: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            valuesCount: raw::c_int,
            values: *mut nvmlFieldValue_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceClearFieldValues: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            valuesCount: raw::c_int,
            values: *mut nvmlFieldValue_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVirtualizationMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pVirtualMode: *mut nvmlGpuVirtualizationMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHostVgpuMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pHostVgpuMode: *mut nvmlHostVgpuMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetVirtualizationMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            virtualMode: nvmlGpuVirtualizationMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGridLicensableFeatures_v4: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetProcessUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut nvmlProcessUtilizationSample_t,
            processSamplesCount: *mut raw::c_uint,
            lastSeenTimeStamp: raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGspFirmwareVersion: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, version: *mut raw::c_char) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGspFirmwareMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            isEnabled: *mut raw::c_uint,
            defaultMode: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetVgpuDriverCapabilities: Result<
        unsafe extern "C" fn(
            capability: nvmlVgpuDriverCapability_t,
            capResult: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuCapabilities: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            capability: nvmlDeviceVgpuCapability_t,
            capResult: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedVgpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuCount: *mut raw::c_uint,
            vgpuTypeIds: *mut nvmlVgpuTypeId_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCreatableVgpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuCount: *mut raw::c_uint,
            vgpuTypeIds: *mut nvmlVgpuTypeId_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetClass: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuTypeClass: *mut raw::c_char,
            size: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetName: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuTypeName: *mut raw::c_char,
            size: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetGpuInstanceProfileId: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            gpuInstanceProfileId: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetDeviceID: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            deviceID: *mut raw::c_ulonglong,
            subsystemID: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetFramebufferSize: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            fbSize: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetNumDisplayHeads: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            numDisplayHeads: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetResolution: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            displayIndex: raw::c_uint,
            xdim: *mut raw::c_uint,
            ydim: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetLicense: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuTypeLicenseString: *mut raw::c_char,
            size: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetFrameRateLimit: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            frameRateLimit: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetMaxInstances: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuInstanceCount: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetMaxInstancesPerVm: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuInstanceCountPerVm: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetActiveVgpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuCount: *mut raw::c_uint,
            vgpuInstances: *mut nvmlVgpuInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetVmID: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            vmId: *mut raw::c_char,
            size: raw::c_uint,
            vmIdType: *mut nvmlVgpuVmIdType_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetUUID: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            uuid: *mut raw::c_char,
            size: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetVmDriverVersion: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFbUsage: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            fbUsage: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetLicenseStatus: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            licensed: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetType: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            vgpuTypeId: *mut nvmlVgpuTypeId_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFrameRateLimit: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            frameRateLimit: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEccMode: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            eccMode: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEncoderCapacity: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            encoderCapacity: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceSetEncoderCapacity: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            encoderCapacity: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEncoderStats: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            sessionCount: *mut raw::c_uint,
            averageFps: *mut raw::c_uint,
            averageLatency: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEncoderSessions: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            sessionCount: *mut raw::c_uint,
            sessionInfo: *mut nvmlEncoderSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFBCStats: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            fbcStats: *mut nvmlFBCStats_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFBCSessions: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            sessionCount: *mut raw::c_uint,
            sessionInfo: *mut nvmlFBCSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetGpuInstanceId: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            gpuInstanceId: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetGpuPciId: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            vgpuPciId: *mut raw::c_char,
            length: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetCapabilities: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            capability: nvmlVgpuCapability_t,
            capResult: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetMetadata: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            vgpuMetadata: *mut nvmlVgpuMetadata_t,
            bufferSize: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuMetadata: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
            bufferSize: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetVgpuCompatibility: Result<
        unsafe extern "C" fn(
            vgpuMetadata: *mut nvmlVgpuMetadata_t,
            pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
            compatibilityInfo: *mut nvmlVgpuPgpuCompatibility_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPgpuMetadataString: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pgpuMetadata: *mut raw::c_char,
            bufferSize: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuSchedulerLog: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pSchedulerLog: *mut nvmlVgpuSchedulerLog_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuSchedulerState: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pSchedulerState: *mut nvmlVgpuSchedulerGetState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuSchedulerCapabilities: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pCapabilities: *mut nvmlVgpuSchedulerCapabilities_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetVgpuSchedulerState: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pSchedulerState: *mut nvmlVgpuSchedulerSetState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetVgpuVersion: Result<
        unsafe extern "C" fn(
            supported: *mut nvmlVgpuVersion_t,
            current: *mut nvmlVgpuVersion_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSetVgpuVersion: Result<
        unsafe extern "C" fn(vgpuVersion: *mut nvmlVgpuVersion_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            lastSeenTimeStamp: raw::c_ulonglong,
            sampleValType: *mut nvmlValueType_t,
            vgpuInstanceSamplesCount: *mut raw::c_uint,
            utilizationSamples: *mut nvmlVgpuInstanceUtilizationSample_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuProcessUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            lastSeenTimeStamp: raw::c_ulonglong,
            vgpuProcessSamplesCount: *mut raw::c_uint,
            utilizationSamples: *mut nvmlVgpuProcessUtilizationSample_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetAccountingMode: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            mode: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetAccountingPids: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            count: *mut raw::c_uint,
            pids: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetAccountingStats: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            pid: raw::c_uint,
            stats: *mut nvmlAccountingStats_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceClearAccountingPids: Result<
        unsafe extern "C" fn(vgpuInstance: nvmlVgpuInstance_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetLicenseInfo_v2: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            licenseInfo: *mut nvmlVgpuLicenseInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetExcludedDeviceCount: Result<
        unsafe extern "C" fn(deviceCount: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetExcludedDeviceInfoByIndex: Result<
        unsafe extern "C" fn(
            index: raw::c_uint,
            info: *mut nvmlExcludedDeviceInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetMigMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            mode: raw::c_uint,
            activationStatus: *mut nvmlReturn_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMigMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            currentMode: *mut raw::c_uint,
            pendingMode: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceProfileInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profile: raw::c_uint,
            info: *mut nvmlGpuInstanceProfileInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceProfileInfoV: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profile: raw::c_uint,
            info: *mut nvmlGpuInstanceProfileInfo_v2_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstancePossiblePlacements_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            placements: *mut nvmlGpuInstancePlacement_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceRemainingCapacity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceCreateGpuInstance: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            gpuInstance: *mut nvmlGpuInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceCreateGpuInstanceWithPlacement: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            placement: *const nvmlGpuInstancePlacement_t,
            gpuInstance: *mut nvmlGpuInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceDestroy: Result<
        unsafe extern "C" fn(gpuInstance: nvmlGpuInstance_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstances: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            gpuInstances: *mut nvmlGpuInstance_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceById: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            id: raw::c_uint,
            gpuInstance: *mut nvmlGpuInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetInfo: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            info: *mut nvmlGpuInstanceInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstanceProfileInfo: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profile: raw::c_uint,
            engProfile: raw::c_uint,
            info: *mut nvmlComputeInstanceProfileInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstanceProfileInfoV: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profile: raw::c_uint,
            engProfile: raw::c_uint,
            info: *mut nvmlComputeInstanceProfileInfo_v2_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstanceRemainingCapacity: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstancePossiblePlacements: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            placements: *mut nvmlComputeInstancePlacement_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceCreateComputeInstance: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            computeInstance: *mut nvmlComputeInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceCreateComputeInstanceWithPlacement: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            placement: *const nvmlComputeInstancePlacement_t,
            computeInstance: *mut nvmlComputeInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlComputeInstanceDestroy: Result<
        unsafe extern "C" fn(computeInstance: nvmlComputeInstance_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstances: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            computeInstances: *mut nvmlComputeInstance_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstanceById: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            id: raw::c_uint,
            computeInstance: *mut nvmlComputeInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlComputeInstanceGetInfo_v2: Result<
        unsafe extern "C" fn(
            computeInstance: nvmlComputeInstance_t,
            info: *mut nvmlComputeInstanceInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceIsMigDeviceHandle: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, isMigDevice: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceId: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, id: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetComputeInstanceId: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, id: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxMigDeviceCount: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, count: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMigDeviceHandleByIndex: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            index: raw::c_uint,
            migDevice: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDeviceHandleFromMigDeviceHandle: Result<
        unsafe extern "C" fn(migDevice: nvmlDevice_t, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpmMetricsGet: Result<
        unsafe extern "C" fn(metricsGet: *mut nvmlGpmMetricsGet_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpmSampleFree: Result<
        unsafe extern "C" fn(gpmSample: nvmlGpmSample_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpmSampleAlloc: Result<
        unsafe extern "C" fn(gpmSample: *mut nvmlGpmSample_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpmSampleGet: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, gpmSample: nvmlGpmSample_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpmMigSampleGet: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            gpuInstanceId: raw::c_uint,
            gpmSample: nvmlGpmSample_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpmQueryDeviceSupport: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            gpmSupport: *mut nvmlGpmSupport_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpmQueryIfStreamingEnabled: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, state: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpmSetStreamingEnabled: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, state: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetNvLinkDeviceLowPowerThreshold: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            info: *mut nvmlNvLinkPowerThres_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemSetNvlinkBwMode: Result<
        unsafe extern "C" fn(nvlinkBwMode: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetNvlinkBwMode: Result<
        unsafe extern "C" fn(nvlinkBwMode: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetPowerManagementLimit_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            powerValue: *mut nvmlPowerValue_v2_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlInit: Result<unsafe extern "C" fn() -> nvmlReturn_t, ::libloading::Error>,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetCount: Result<
        unsafe extern "C" fn(deviceCount: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetHandleByIndex: Result<
        unsafe extern "C" fn(index: raw::c_uint, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetHandleByPciBusId: Result<
        unsafe extern "C" fn(
            pciBusId: *const raw::c_char,
            device: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetPciInfo: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pci: *mut nvmlPciInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetPciInfo_v2: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pci: *mut nvmlPciInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetNvLinkRemotePciInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            pci: *mut nvmlPciInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetGridLicensableFeatures: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetGridLicensableFeatures_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetGridLicensableFeatures_v3: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceRemoveGpu: Result<
        unsafe extern "C" fn(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlEventSetWait: Result<
        unsafe extern "C" fn(
            set: nvmlEventSet_t,
            data: *mut nvmlEventData_t,
            timeoutms: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetAttributes: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            attributes: *mut nvmlDeviceAttributes_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlComputeInstanceGetInfo: Result<
        unsafe extern "C" fn(
            computeInstance: nvmlComputeInstance_t,
            info: *mut nvmlComputeInstanceInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetComputeRunningProcesses: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_v1_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetComputeRunningProcesses_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_v2_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetGraphicsRunningProcesses: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_v1_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetGraphicsRunningProcesses_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_v2_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetMPSComputeRunningProcesses: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_v1_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetMPSComputeRunningProcesses_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_v2_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlDeviceGetGpuInstancePossiblePlacements: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            placements: *mut nvmlGpuInstancePlacement_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    #[cfg(feature = "legacy-functions")]
    pub nvmlVgpuInstanceGetLicenseInfo: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            licenseInfo: *mut nvmlVgpuLicenseInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
}
impl NvmlLib {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let nvmlInit_v2 = __library.get(b"nvmlInit_v2\0").map(|sym| *sym);
        let nvmlInitWithFlags = __library.get(b"nvmlInitWithFlags\0").map(|sym| *sym);
        let nvmlShutdown = __library.get(b"nvmlShutdown\0").map(|sym| *sym);
        let nvmlErrorString = __library.get(b"nvmlErrorString\0").map(|sym| *sym);
        let nvmlSystemGetDriverVersion = __library
            .get(b"nvmlSystemGetDriverVersion\0")
            .map(|sym| *sym);
        let nvmlSystemGetNVMLVersion = __library.get(b"nvmlSystemGetNVMLVersion\0").map(|sym| *sym);
        let nvmlSystemGetCudaDriverVersion = __library
            .get(b"nvmlSystemGetCudaDriverVersion\0")
            .map(|sym| *sym);
        let nvmlSystemGetCudaDriverVersion_v2 = __library
            .get(b"nvmlSystemGetCudaDriverVersion_v2\0")
            .map(|sym| *sym);
        let nvmlSystemGetProcessName = __library.get(b"nvmlSystemGetProcessName\0").map(|sym| *sym);
        let nvmlUnitGetCount = __library.get(b"nvmlUnitGetCount\0").map(|sym| *sym);
        let nvmlUnitGetHandleByIndex = __library.get(b"nvmlUnitGetHandleByIndex\0").map(|sym| *sym);
        let nvmlUnitGetUnitInfo = __library.get(b"nvmlUnitGetUnitInfo\0").map(|sym| *sym);
        let nvmlUnitGetLedState = __library.get(b"nvmlUnitGetLedState\0").map(|sym| *sym);
        let nvmlUnitGetPsuInfo = __library.get(b"nvmlUnitGetPsuInfo\0").map(|sym| *sym);
        let nvmlUnitGetTemperature = __library.get(b"nvmlUnitGetTemperature\0").map(|sym| *sym);
        let nvmlUnitGetFanSpeedInfo = __library.get(b"nvmlUnitGetFanSpeedInfo\0").map(|sym| *sym);
        let nvmlUnitGetDevices = __library.get(b"nvmlUnitGetDevices\0").map(|sym| *sym);
        let nvmlSystemGetHicVersion = __library.get(b"nvmlSystemGetHicVersion\0").map(|sym| *sym);
        let nvmlDeviceGetCount_v2 = __library.get(b"nvmlDeviceGetCount_v2\0").map(|sym| *sym);
        let nvmlDeviceGetAttributes_v2 = __library
            .get(b"nvmlDeviceGetAttributes_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetHandleByIndex_v2 = __library
            .get(b"nvmlDeviceGetHandleByIndex_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetHandleBySerial = __library
            .get(b"nvmlDeviceGetHandleBySerial\0")
            .map(|sym| *sym);
        let nvmlDeviceGetHandleByUUID = __library
            .get(b"nvmlDeviceGetHandleByUUID\0")
            .map(|sym| *sym);
        let nvmlDeviceGetHandleByPciBusId_v2 = __library
            .get(b"nvmlDeviceGetHandleByPciBusId_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetName = __library.get(b"nvmlDeviceGetName\0").map(|sym| *sym);
        let nvmlDeviceGetBrand = __library.get(b"nvmlDeviceGetBrand\0").map(|sym| *sym);
        let nvmlDeviceGetIndex = __library.get(b"nvmlDeviceGetIndex\0").map(|sym| *sym);
        let nvmlDeviceGetSerial = __library.get(b"nvmlDeviceGetSerial\0").map(|sym| *sym);
        let nvmlDeviceGetModuleId = __library.get(b"nvmlDeviceGetModuleId\0").map(|sym| *sym);
        let nvmlDeviceGetMemoryAffinity = __library
            .get(b"nvmlDeviceGetMemoryAffinity\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCpuAffinityWithinScope = __library
            .get(b"nvmlDeviceGetCpuAffinityWithinScope\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCpuAffinity = __library.get(b"nvmlDeviceGetCpuAffinity\0").map(|sym| *sym);
        let nvmlDeviceSetCpuAffinity = __library.get(b"nvmlDeviceSetCpuAffinity\0").map(|sym| *sym);
        let nvmlDeviceClearCpuAffinity = __library
            .get(b"nvmlDeviceClearCpuAffinity\0")
            .map(|sym| *sym);
        let nvmlDeviceGetTopologyCommonAncestor = __library
            .get(b"nvmlDeviceGetTopologyCommonAncestor\0")
            .map(|sym| *sym);
        let nvmlDeviceGetTopologyNearestGpus = __library
            .get(b"nvmlDeviceGetTopologyNearestGpus\0")
            .map(|sym| *sym);
        let nvmlSystemGetTopologyGpuSet = __library
            .get(b"nvmlSystemGetTopologyGpuSet\0")
            .map(|sym| *sym);
        let nvmlDeviceGetP2PStatus = __library.get(b"nvmlDeviceGetP2PStatus\0").map(|sym| *sym);
        let nvmlDeviceGetUUID = __library.get(b"nvmlDeviceGetUUID\0").map(|sym| *sym);
        let nvmlVgpuInstanceGetMdevUUID = __library
            .get(b"nvmlVgpuInstanceGetMdevUUID\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMinorNumber = __library.get(b"nvmlDeviceGetMinorNumber\0").map(|sym| *sym);
        let nvmlDeviceGetBoardPartNumber = __library
            .get(b"nvmlDeviceGetBoardPartNumber\0")
            .map(|sym| *sym);
        let nvmlDeviceGetInforomVersion = __library
            .get(b"nvmlDeviceGetInforomVersion\0")
            .map(|sym| *sym);
        let nvmlDeviceGetInforomImageVersion = __library
            .get(b"nvmlDeviceGetInforomImageVersion\0")
            .map(|sym| *sym);
        let nvmlDeviceGetInforomConfigurationChecksum = __library
            .get(b"nvmlDeviceGetInforomConfigurationChecksum\0")
            .map(|sym| *sym);
        let nvmlDeviceValidateInforom = __library
            .get(b"nvmlDeviceValidateInforom\0")
            .map(|sym| *sym);
        let nvmlDeviceGetDisplayMode = __library.get(b"nvmlDeviceGetDisplayMode\0").map(|sym| *sym);
        let nvmlDeviceGetDisplayActive = __library
            .get(b"nvmlDeviceGetDisplayActive\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPersistenceMode = __library
            .get(b"nvmlDeviceGetPersistenceMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPciInfo_v3 = __library.get(b"nvmlDeviceGetPciInfo_v3\0").map(|sym| *sym);
        let nvmlDeviceGetMaxPcieLinkGeneration = __library
            .get(b"nvmlDeviceGetMaxPcieLinkGeneration\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuMaxPcieLinkGeneration = __library
            .get(b"nvmlDeviceGetGpuMaxPcieLinkGeneration\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMaxPcieLinkWidth = __library
            .get(b"nvmlDeviceGetMaxPcieLinkWidth\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCurrPcieLinkGeneration = __library
            .get(b"nvmlDeviceGetCurrPcieLinkGeneration\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCurrPcieLinkWidth = __library
            .get(b"nvmlDeviceGetCurrPcieLinkWidth\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPcieThroughput = __library
            .get(b"nvmlDeviceGetPcieThroughput\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPcieReplayCounter = __library
            .get(b"nvmlDeviceGetPcieReplayCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceGetClockInfo = __library.get(b"nvmlDeviceGetClockInfo\0").map(|sym| *sym);
        let nvmlDeviceGetMaxClockInfo = __library
            .get(b"nvmlDeviceGetMaxClockInfo\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpcClkVfOffset = __library
            .get(b"nvmlDeviceGetGpcClkVfOffset\0")
            .map(|sym| *sym);
        let nvmlDeviceGetApplicationsClock = __library
            .get(b"nvmlDeviceGetApplicationsClock\0")
            .map(|sym| *sym);
        let nvmlDeviceGetDefaultApplicationsClock = __library
            .get(b"nvmlDeviceGetDefaultApplicationsClock\0")
            .map(|sym| *sym);
        let nvmlDeviceResetApplicationsClocks = __library
            .get(b"nvmlDeviceResetApplicationsClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceGetClock = __library.get(b"nvmlDeviceGetClock\0").map(|sym| *sym);
        let nvmlDeviceGetMaxCustomerBoostClock = __library
            .get(b"nvmlDeviceGetMaxCustomerBoostClock\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedMemoryClocks = __library
            .get(b"nvmlDeviceGetSupportedMemoryClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedGraphicsClocks = __library
            .get(b"nvmlDeviceGetSupportedGraphicsClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceGetAutoBoostedClocksEnabled = __library
            .get(b"nvmlDeviceGetAutoBoostedClocksEnabled\0")
            .map(|sym| *sym);
        let nvmlDeviceSetAutoBoostedClocksEnabled = __library
            .get(b"nvmlDeviceSetAutoBoostedClocksEnabled\0")
            .map(|sym| *sym);
        let nvmlDeviceSetDefaultAutoBoostedClocksEnabled = __library
            .get(b"nvmlDeviceSetDefaultAutoBoostedClocksEnabled\0")
            .map(|sym| *sym);
        let nvmlDeviceGetFanSpeed = __library.get(b"nvmlDeviceGetFanSpeed\0").map(|sym| *sym);
        let nvmlDeviceGetFanSpeed_v2 = __library.get(b"nvmlDeviceGetFanSpeed_v2\0").map(|sym| *sym);
        let nvmlDeviceGetTargetFanSpeed = __library
            .get(b"nvmlDeviceGetTargetFanSpeed\0")
            .map(|sym| *sym);
        let nvmlDeviceSetDefaultFanSpeed_v2 = __library
            .get(b"nvmlDeviceSetDefaultFanSpeed_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMinMaxFanSpeed = __library
            .get(b"nvmlDeviceGetMinMaxFanSpeed\0")
            .map(|sym| *sym);
        let nvmlDeviceGetFanControlPolicy_v2 = __library
            .get(b"nvmlDeviceGetFanControlPolicy_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceSetFanControlPolicy = __library
            .get(b"nvmlDeviceSetFanControlPolicy\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNumFans = __library.get(b"nvmlDeviceGetNumFans\0").map(|sym| *sym);
        let nvmlDeviceGetTemperature = __library.get(b"nvmlDeviceGetTemperature\0").map(|sym| *sym);
        let nvmlDeviceGetTemperatureThreshold = __library
            .get(b"nvmlDeviceGetTemperatureThreshold\0")
            .map(|sym| *sym);
        let nvmlDeviceSetTemperatureThreshold = __library
            .get(b"nvmlDeviceSetTemperatureThreshold\0")
            .map(|sym| *sym);
        let nvmlDeviceGetThermalSettings = __library
            .get(b"nvmlDeviceGetThermalSettings\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPerformanceState = __library
            .get(b"nvmlDeviceGetPerformanceState\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCurrentClocksEventReasons = __library
            .get(b"nvmlDeviceGetCurrentClocksEventReasons\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCurrentClocksThrottleReasons = __library
            .get(b"nvmlDeviceGetCurrentClocksThrottleReasons\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedClocksEventReasons = __library
            .get(b"nvmlDeviceGetSupportedClocksEventReasons\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedClocksThrottleReasons = __library
            .get(b"nvmlDeviceGetSupportedClocksThrottleReasons\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerState = __library.get(b"nvmlDeviceGetPowerState\0").map(|sym| *sym);
        let nvmlDeviceGetDynamicPstatesInfo = __library
            .get(b"nvmlDeviceGetDynamicPstatesInfo\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMemClkVfOffset = __library
            .get(b"nvmlDeviceGetMemClkVfOffset\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMinMaxClockOfPState = __library
            .get(b"nvmlDeviceGetMinMaxClockOfPState\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedPerformanceStates = __library
            .get(b"nvmlDeviceGetSupportedPerformanceStates\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpcClkMinMaxVfOffset = __library
            .get(b"nvmlDeviceGetGpcClkMinMaxVfOffset\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMemClkMinMaxVfOffset = __library
            .get(b"nvmlDeviceGetMemClkMinMaxVfOffset\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementMode = __library
            .get(b"nvmlDeviceGetPowerManagementMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementLimit = __library
            .get(b"nvmlDeviceGetPowerManagementLimit\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementLimitConstraints = __library
            .get(b"nvmlDeviceGetPowerManagementLimitConstraints\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementDefaultLimit = __library
            .get(b"nvmlDeviceGetPowerManagementDefaultLimit\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPowerUsage = __library.get(b"nvmlDeviceGetPowerUsage\0").map(|sym| *sym);
        let nvmlDeviceGetTotalEnergyConsumption = __library
            .get(b"nvmlDeviceGetTotalEnergyConsumption\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEnforcedPowerLimit = __library
            .get(b"nvmlDeviceGetEnforcedPowerLimit\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuOperationMode = __library
            .get(b"nvmlDeviceGetGpuOperationMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMemoryInfo = __library.get(b"nvmlDeviceGetMemoryInfo\0").map(|sym| *sym);
        let nvmlDeviceGetMemoryInfo_v2 = __library
            .get(b"nvmlDeviceGetMemoryInfo_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetComputeMode = __library.get(b"nvmlDeviceGetComputeMode\0").map(|sym| *sym);
        let nvmlDeviceGetCudaComputeCapability = __library
            .get(b"nvmlDeviceGetCudaComputeCapability\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEccMode = __library.get(b"nvmlDeviceGetEccMode\0").map(|sym| *sym);
        let nvmlDeviceGetDefaultEccMode = __library
            .get(b"nvmlDeviceGetDefaultEccMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetBoardId = __library.get(b"nvmlDeviceGetBoardId\0").map(|sym| *sym);
        let nvmlDeviceGetMultiGpuBoard = __library
            .get(b"nvmlDeviceGetMultiGpuBoard\0")
            .map(|sym| *sym);
        let nvmlDeviceGetTotalEccErrors = __library
            .get(b"nvmlDeviceGetTotalEccErrors\0")
            .map(|sym| *sym);
        let nvmlDeviceGetDetailedEccErrors = __library
            .get(b"nvmlDeviceGetDetailedEccErrors\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMemoryErrorCounter = __library
            .get(b"nvmlDeviceGetMemoryErrorCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceGetUtilizationRates = __library
            .get(b"nvmlDeviceGetUtilizationRates\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderUtilization = __library
            .get(b"nvmlDeviceGetEncoderUtilization\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderCapacity = __library
            .get(b"nvmlDeviceGetEncoderCapacity\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderStats = __library
            .get(b"nvmlDeviceGetEncoderStats\0")
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderSessions = __library
            .get(b"nvmlDeviceGetEncoderSessions\0")
            .map(|sym| *sym);
        let nvmlDeviceGetDecoderUtilization = __library
            .get(b"nvmlDeviceGetDecoderUtilization\0")
            .map(|sym| *sym);
        let nvmlDeviceGetJpgUtilization = __library
            .get(b"nvmlDeviceGetJpgUtilization\0")
            .map(|sym| *sym);
        let nvmlDeviceGetOfaUtilization = __library
            .get(b"nvmlDeviceGetOfaUtilization\0")
            .map(|sym| *sym);
        let nvmlDeviceGetFBCStats = __library.get(b"nvmlDeviceGetFBCStats\0").map(|sym| *sym);
        let nvmlDeviceGetFBCSessions = __library.get(b"nvmlDeviceGetFBCSessions\0").map(|sym| *sym);
        let nvmlDeviceGetDriverModel = __library.get(b"nvmlDeviceGetDriverModel\0").map(|sym| *sym);
        let nvmlDeviceGetVbiosVersion = __library
            .get(b"nvmlDeviceGetVbiosVersion\0")
            .map(|sym| *sym);
        let nvmlDeviceGetBridgeChipInfo = __library
            .get(b"nvmlDeviceGetBridgeChipInfo\0")
            .map(|sym| *sym);
        let nvmlDeviceGetComputeRunningProcesses_v3 = __library
            .get(b"nvmlDeviceGetComputeRunningProcesses_v3\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGraphicsRunningProcesses_v3 = __library
            .get(b"nvmlDeviceGetGraphicsRunningProcesses_v3\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMPSComputeRunningProcesses_v3 = __library
            .get(b"nvmlDeviceGetMPSComputeRunningProcesses_v3\0")
            .map(|sym| *sym);
        let nvmlDeviceGetRunningProcessDetailList = __library
            .get(b"nvmlDeviceGetRunningProcessDetailList\0")
            .map(|sym| *sym);
        let nvmlDeviceOnSameBoard = __library.get(b"nvmlDeviceOnSameBoard\0").map(|sym| *sym);
        let nvmlDeviceGetAPIRestriction = __library
            .get(b"nvmlDeviceGetAPIRestriction\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSamples = __library.get(b"nvmlDeviceGetSamples\0").map(|sym| *sym);
        let nvmlDeviceGetBAR1MemoryInfo = __library
            .get(b"nvmlDeviceGetBAR1MemoryInfo\0")
            .map(|sym| *sym);
        let nvmlDeviceGetViolationStatus = __library
            .get(b"nvmlDeviceGetViolationStatus\0")
            .map(|sym| *sym);
        let nvmlDeviceGetIrqNum = __library.get(b"nvmlDeviceGetIrqNum\0").map(|sym| *sym);
        let nvmlDeviceGetNumGpuCores = __library.get(b"nvmlDeviceGetNumGpuCores\0").map(|sym| *sym);
        let nvmlDeviceGetPowerSource = __library.get(b"nvmlDeviceGetPowerSource\0").map(|sym| *sym);
        let nvmlDeviceGetMemoryBusWidth = __library
            .get(b"nvmlDeviceGetMemoryBusWidth\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPcieLinkMaxSpeed = __library
            .get(b"nvmlDeviceGetPcieLinkMaxSpeed\0")
            .map(|sym| *sym);
        let nvmlDeviceGetPcieSpeed = __library.get(b"nvmlDeviceGetPcieSpeed\0").map(|sym| *sym);
        let nvmlDeviceGetAdaptiveClockInfoStatus = __library
            .get(b"nvmlDeviceGetAdaptiveClockInfoStatus\0")
            .map(|sym| *sym);
        let nvmlDeviceGetBusType = __library.get(b"nvmlDeviceGetBusType\0").map(|sym| *sym);
        let nvmlDeviceGetGpuFabricInfo = __library
            .get(b"nvmlDeviceGetGpuFabricInfo\0")
            .map(|sym| *sym);
        let nvmlSystemGetConfComputeCapabilities = __library
            .get(b"nvmlSystemGetConfComputeCapabilities\0")
            .map(|sym| *sym);
        let nvmlSystemGetConfComputeState = __library
            .get(b"nvmlSystemGetConfComputeState\0")
            .map(|sym| *sym);
        let nvmlDeviceGetConfComputeMemSizeInfo = __library
            .get(b"nvmlDeviceGetConfComputeMemSizeInfo\0")
            .map(|sym| *sym);
        let nvmlSystemGetConfComputeGpusReadyState = __library
            .get(b"nvmlSystemGetConfComputeGpusReadyState\0")
            .map(|sym| *sym);
        let nvmlDeviceGetConfComputeProtectedMemoryUsage = __library
            .get(b"nvmlDeviceGetConfComputeProtectedMemoryUsage\0")
            .map(|sym| *sym);
        let nvmlDeviceGetConfComputeGpuCertificate = __library
            .get(b"nvmlDeviceGetConfComputeGpuCertificate\0")
            .map(|sym| *sym);
        let nvmlDeviceGetConfComputeGpuAttestationReport = __library
            .get(b"nvmlDeviceGetConfComputeGpuAttestationReport\0")
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingMode = __library
            .get(b"nvmlDeviceGetAccountingMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingStats = __library
            .get(b"nvmlDeviceGetAccountingStats\0")
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingPids = __library
            .get(b"nvmlDeviceGetAccountingPids\0")
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingBufferSize = __library
            .get(b"nvmlDeviceGetAccountingBufferSize\0")
            .map(|sym| *sym);
        let nvmlDeviceGetRetiredPages = __library
            .get(b"nvmlDeviceGetRetiredPages\0")
            .map(|sym| *sym);
        let nvmlDeviceGetRetiredPages_v2 = __library
            .get(b"nvmlDeviceGetRetiredPages_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetRetiredPagesPendingStatus = __library
            .get(b"nvmlDeviceGetRetiredPagesPendingStatus\0")
            .map(|sym| *sym);
        let nvmlDeviceGetRemappedRows = __library
            .get(b"nvmlDeviceGetRemappedRows\0")
            .map(|sym| *sym);
        let nvmlDeviceGetRowRemapperHistogram = __library
            .get(b"nvmlDeviceGetRowRemapperHistogram\0")
            .map(|sym| *sym);
        let nvmlDeviceGetArchitecture = __library
            .get(b"nvmlDeviceGetArchitecture\0")
            .map(|sym| *sym);
        let nvmlUnitSetLedState = __library.get(b"nvmlUnitSetLedState\0").map(|sym| *sym);
        let nvmlDeviceSetPersistenceMode = __library
            .get(b"nvmlDeviceSetPersistenceMode\0")
            .map(|sym| *sym);
        let nvmlDeviceSetComputeMode = __library.get(b"nvmlDeviceSetComputeMode\0").map(|sym| *sym);
        let nvmlDeviceSetEccMode = __library.get(b"nvmlDeviceSetEccMode\0").map(|sym| *sym);
        let nvmlDeviceClearEccErrorCounts = __library
            .get(b"nvmlDeviceClearEccErrorCounts\0")
            .map(|sym| *sym);
        let nvmlDeviceSetDriverModel = __library.get(b"nvmlDeviceSetDriverModel\0").map(|sym| *sym);
        let nvmlDeviceSetGpuLockedClocks = __library
            .get(b"nvmlDeviceSetGpuLockedClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceResetGpuLockedClocks = __library
            .get(b"nvmlDeviceResetGpuLockedClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceSetMemoryLockedClocks = __library
            .get(b"nvmlDeviceSetMemoryLockedClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceResetMemoryLockedClocks = __library
            .get(b"nvmlDeviceResetMemoryLockedClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceSetApplicationsClocks = __library
            .get(b"nvmlDeviceSetApplicationsClocks\0")
            .map(|sym| *sym);
        let nvmlDeviceGetClkMonStatus = __library
            .get(b"nvmlDeviceGetClkMonStatus\0")
            .map(|sym| *sym);
        let nvmlDeviceSetPowerManagementLimit = __library
            .get(b"nvmlDeviceSetPowerManagementLimit\0")
            .map(|sym| *sym);
        let nvmlDeviceSetGpuOperationMode = __library
            .get(b"nvmlDeviceSetGpuOperationMode\0")
            .map(|sym| *sym);
        let nvmlDeviceSetAPIRestriction = __library
            .get(b"nvmlDeviceSetAPIRestriction\0")
            .map(|sym| *sym);
        let nvmlDeviceSetFanSpeed_v2 = __library.get(b"nvmlDeviceSetFanSpeed_v2\0").map(|sym| *sym);
        let nvmlDeviceSetGpcClkVfOffset = __library
            .get(b"nvmlDeviceSetGpcClkVfOffset\0")
            .map(|sym| *sym);
        let nvmlDeviceSetMemClkVfOffset = __library
            .get(b"nvmlDeviceSetMemClkVfOffset\0")
            .map(|sym| *sym);
        let nvmlDeviceSetConfComputeUnprotectedMemSize = __library
            .get(b"nvmlDeviceSetConfComputeUnprotectedMemSize\0")
            .map(|sym| *sym);
        let nvmlSystemSetConfComputeGpusReadyState = __library
            .get(b"nvmlSystemSetConfComputeGpusReadyState\0")
            .map(|sym| *sym);
        let nvmlDeviceSetAccountingMode = __library
            .get(b"nvmlDeviceSetAccountingMode\0")
            .map(|sym| *sym);
        let nvmlDeviceClearAccountingPids = __library
            .get(b"nvmlDeviceClearAccountingPids\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkState = __library.get(b"nvmlDeviceGetNvLinkState\0").map(|sym| *sym);
        let nvmlDeviceGetNvLinkVersion = __library
            .get(b"nvmlDeviceGetNvLinkVersion\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkCapability = __library
            .get(b"nvmlDeviceGetNvLinkCapability\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkRemotePciInfo_v2 = __library
            .get(b"nvmlDeviceGetNvLinkRemotePciInfo_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkErrorCounter = __library
            .get(b"nvmlDeviceGetNvLinkErrorCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceResetNvLinkErrorCounters = __library
            .get(b"nvmlDeviceResetNvLinkErrorCounters\0")
            .map(|sym| *sym);
        let nvmlDeviceSetNvLinkUtilizationControl = __library
            .get(b"nvmlDeviceSetNvLinkUtilizationControl\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkUtilizationControl = __library
            .get(b"nvmlDeviceGetNvLinkUtilizationControl\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkUtilizationCounter = __library
            .get(b"nvmlDeviceGetNvLinkUtilizationCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceFreezeNvLinkUtilizationCounter = __library
            .get(b"nvmlDeviceFreezeNvLinkUtilizationCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceResetNvLinkUtilizationCounter = __library
            .get(b"nvmlDeviceResetNvLinkUtilizationCounter\0")
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkRemoteDeviceType = __library
            .get(b"nvmlDeviceGetNvLinkRemoteDeviceType\0")
            .map(|sym| *sym);
        let nvmlEventSetCreate = __library.get(b"nvmlEventSetCreate\0").map(|sym| *sym);
        let nvmlDeviceRegisterEvents = __library.get(b"nvmlDeviceRegisterEvents\0").map(|sym| *sym);
        let nvmlDeviceGetSupportedEventTypes = __library
            .get(b"nvmlDeviceGetSupportedEventTypes\0")
            .map(|sym| *sym);
        let nvmlEventSetWait_v2 = __library.get(b"nvmlEventSetWait_v2\0").map(|sym| *sym);
        let nvmlEventSetFree = __library.get(b"nvmlEventSetFree\0").map(|sym| *sym);
        let nvmlDeviceModifyDrainState = __library
            .get(b"nvmlDeviceModifyDrainState\0")
            .map(|sym| *sym);
        let nvmlDeviceQueryDrainState = __library
            .get(b"nvmlDeviceQueryDrainState\0")
            .map(|sym| *sym);
        let nvmlDeviceRemoveGpu_v2 = __library.get(b"nvmlDeviceRemoveGpu_v2\0").map(|sym| *sym);
        let nvmlDeviceDiscoverGpus = __library.get(b"nvmlDeviceDiscoverGpus\0").map(|sym| *sym);
        let nvmlDeviceGetFieldValues = __library.get(b"nvmlDeviceGetFieldValues\0").map(|sym| *sym);
        let nvmlDeviceClearFieldValues = __library
            .get(b"nvmlDeviceClearFieldValues\0")
            .map(|sym| *sym);
        let nvmlDeviceGetVirtualizationMode = __library
            .get(b"nvmlDeviceGetVirtualizationMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetHostVgpuMode = __library
            .get(b"nvmlDeviceGetHostVgpuMode\0")
            .map(|sym| *sym);
        let nvmlDeviceSetVirtualizationMode = __library
            .get(b"nvmlDeviceSetVirtualizationMode\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGridLicensableFeatures_v4 = __library
            .get(b"nvmlDeviceGetGridLicensableFeatures_v4\0")
            .map(|sym| *sym);
        let nvmlDeviceGetProcessUtilization = __library
            .get(b"nvmlDeviceGetProcessUtilization\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGspFirmwareVersion = __library
            .get(b"nvmlDeviceGetGspFirmwareVersion\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGspFirmwareMode = __library
            .get(b"nvmlDeviceGetGspFirmwareMode\0")
            .map(|sym| *sym);
        let nvmlGetVgpuDriverCapabilities = __library
            .get(b"nvmlGetVgpuDriverCapabilities\0")
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuCapabilities = __library
            .get(b"nvmlDeviceGetVgpuCapabilities\0")
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedVgpus = __library
            .get(b"nvmlDeviceGetSupportedVgpus\0")
            .map(|sym| *sym);
        let nvmlDeviceGetCreatableVgpus = __library
            .get(b"nvmlDeviceGetCreatableVgpus\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetClass = __library.get(b"nvmlVgpuTypeGetClass\0").map(|sym| *sym);
        let nvmlVgpuTypeGetName = __library.get(b"nvmlVgpuTypeGetName\0").map(|sym| *sym);
        let nvmlVgpuTypeGetGpuInstanceProfileId = __library
            .get(b"nvmlVgpuTypeGetGpuInstanceProfileId\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetDeviceID = __library.get(b"nvmlVgpuTypeGetDeviceID\0").map(|sym| *sym);
        let nvmlVgpuTypeGetFramebufferSize = __library
            .get(b"nvmlVgpuTypeGetFramebufferSize\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetNumDisplayHeads = __library
            .get(b"nvmlVgpuTypeGetNumDisplayHeads\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetResolution = __library
            .get(b"nvmlVgpuTypeGetResolution\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetLicense = __library.get(b"nvmlVgpuTypeGetLicense\0").map(|sym| *sym);
        let nvmlVgpuTypeGetFrameRateLimit = __library
            .get(b"nvmlVgpuTypeGetFrameRateLimit\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetMaxInstances = __library
            .get(b"nvmlVgpuTypeGetMaxInstances\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetMaxInstancesPerVm = __library
            .get(b"nvmlVgpuTypeGetMaxInstancesPerVm\0")
            .map(|sym| *sym);
        let nvmlDeviceGetActiveVgpus = __library.get(b"nvmlDeviceGetActiveVgpus\0").map(|sym| *sym);
        let nvmlVgpuInstanceGetVmID = __library.get(b"nvmlVgpuInstanceGetVmID\0").map(|sym| *sym);
        let nvmlVgpuInstanceGetUUID = __library.get(b"nvmlVgpuInstanceGetUUID\0").map(|sym| *sym);
        let nvmlVgpuInstanceGetVmDriverVersion = __library
            .get(b"nvmlVgpuInstanceGetVmDriverVersion\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetFbUsage = __library
            .get(b"nvmlVgpuInstanceGetFbUsage\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetLicenseStatus = __library
            .get(b"nvmlVgpuInstanceGetLicenseStatus\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetType = __library.get(b"nvmlVgpuInstanceGetType\0").map(|sym| *sym);
        let nvmlVgpuInstanceGetFrameRateLimit = __library
            .get(b"nvmlVgpuInstanceGetFrameRateLimit\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEccMode = __library
            .get(b"nvmlVgpuInstanceGetEccMode\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEncoderCapacity = __library
            .get(b"nvmlVgpuInstanceGetEncoderCapacity\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceSetEncoderCapacity = __library
            .get(b"nvmlVgpuInstanceSetEncoderCapacity\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEncoderStats = __library
            .get(b"nvmlVgpuInstanceGetEncoderStats\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEncoderSessions = __library
            .get(b"nvmlVgpuInstanceGetEncoderSessions\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetFBCStats = __library
            .get(b"nvmlVgpuInstanceGetFBCStats\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetFBCSessions = __library
            .get(b"nvmlVgpuInstanceGetFBCSessions\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetGpuInstanceId = __library
            .get(b"nvmlVgpuInstanceGetGpuInstanceId\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetGpuPciId = __library
            .get(b"nvmlVgpuInstanceGetGpuPciId\0")
            .map(|sym| *sym);
        let nvmlVgpuTypeGetCapabilities = __library
            .get(b"nvmlVgpuTypeGetCapabilities\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetMetadata = __library
            .get(b"nvmlVgpuInstanceGetMetadata\0")
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuMetadata = __library
            .get(b"nvmlDeviceGetVgpuMetadata\0")
            .map(|sym| *sym);
        let nvmlGetVgpuCompatibility = __library.get(b"nvmlGetVgpuCompatibility\0").map(|sym| *sym);
        let nvmlDeviceGetPgpuMetadataString = __library
            .get(b"nvmlDeviceGetPgpuMetadataString\0")
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuSchedulerLog = __library
            .get(b"nvmlDeviceGetVgpuSchedulerLog\0")
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuSchedulerState = __library
            .get(b"nvmlDeviceGetVgpuSchedulerState\0")
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuSchedulerCapabilities = __library
            .get(b"nvmlDeviceGetVgpuSchedulerCapabilities\0")
            .map(|sym| *sym);
        let nvmlDeviceSetVgpuSchedulerState = __library
            .get(b"nvmlDeviceSetVgpuSchedulerState\0")
            .map(|sym| *sym);
        let nvmlGetVgpuVersion = __library.get(b"nvmlGetVgpuVersion\0").map(|sym| *sym);
        let nvmlSetVgpuVersion = __library.get(b"nvmlSetVgpuVersion\0").map(|sym| *sym);
        let nvmlDeviceGetVgpuUtilization = __library
            .get(b"nvmlDeviceGetVgpuUtilization\0")
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuProcessUtilization = __library
            .get(b"nvmlDeviceGetVgpuProcessUtilization\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetAccountingMode = __library
            .get(b"nvmlVgpuInstanceGetAccountingMode\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetAccountingPids = __library
            .get(b"nvmlVgpuInstanceGetAccountingPids\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetAccountingStats = __library
            .get(b"nvmlVgpuInstanceGetAccountingStats\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceClearAccountingPids = __library
            .get(b"nvmlVgpuInstanceClearAccountingPids\0")
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetLicenseInfo_v2 = __library
            .get(b"nvmlVgpuInstanceGetLicenseInfo_v2\0")
            .map(|sym| *sym);
        let nvmlGetExcludedDeviceCount = __library
            .get(b"nvmlGetExcludedDeviceCount\0")
            .map(|sym| *sym);
        let nvmlGetExcludedDeviceInfoByIndex = __library
            .get(b"nvmlGetExcludedDeviceInfoByIndex\0")
            .map(|sym| *sym);
        let nvmlDeviceSetMigMode = __library.get(b"nvmlDeviceSetMigMode\0").map(|sym| *sym);
        let nvmlDeviceGetMigMode = __library.get(b"nvmlDeviceGetMigMode\0").map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceProfileInfo = __library
            .get(b"nvmlDeviceGetGpuInstanceProfileInfo\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceProfileInfoV = __library
            .get(b"nvmlDeviceGetGpuInstanceProfileInfoV\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstancePossiblePlacements_v2 = __library
            .get(b"nvmlDeviceGetGpuInstancePossiblePlacements_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceRemainingCapacity = __library
            .get(b"nvmlDeviceGetGpuInstanceRemainingCapacity\0")
            .map(|sym| *sym);
        let nvmlDeviceCreateGpuInstance = __library
            .get(b"nvmlDeviceCreateGpuInstance\0")
            .map(|sym| *sym);
        let nvmlDeviceCreateGpuInstanceWithPlacement = __library
            .get(b"nvmlDeviceCreateGpuInstanceWithPlacement\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceDestroy = __library.get(b"nvmlGpuInstanceDestroy\0").map(|sym| *sym);
        let nvmlDeviceGetGpuInstances = __library
            .get(b"nvmlDeviceGetGpuInstances\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceById = __library
            .get(b"nvmlDeviceGetGpuInstanceById\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceGetInfo = __library.get(b"nvmlGpuInstanceGetInfo\0").map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstanceProfileInfo = __library
            .get(b"nvmlGpuInstanceGetComputeInstanceProfileInfo\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstanceProfileInfoV = __library
            .get(b"nvmlGpuInstanceGetComputeInstanceProfileInfoV\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstanceRemainingCapacity = __library
            .get(b"nvmlGpuInstanceGetComputeInstanceRemainingCapacity\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstancePossiblePlacements = __library
            .get(b"nvmlGpuInstanceGetComputeInstancePossiblePlacements\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceCreateComputeInstance = __library
            .get(b"nvmlGpuInstanceCreateComputeInstance\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceCreateComputeInstanceWithPlacement = __library
            .get(b"nvmlGpuInstanceCreateComputeInstanceWithPlacement\0")
            .map(|sym| *sym);
        let nvmlComputeInstanceDestroy = __library
            .get(b"nvmlComputeInstanceDestroy\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstances = __library
            .get(b"nvmlGpuInstanceGetComputeInstances\0")
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstanceById = __library
            .get(b"nvmlGpuInstanceGetComputeInstanceById\0")
            .map(|sym| *sym);
        let nvmlComputeInstanceGetInfo_v2 = __library
            .get(b"nvmlComputeInstanceGetInfo_v2\0")
            .map(|sym| *sym);
        let nvmlDeviceIsMigDeviceHandle = __library
            .get(b"nvmlDeviceIsMigDeviceHandle\0")
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceId = __library
            .get(b"nvmlDeviceGetGpuInstanceId\0")
            .map(|sym| *sym);
        let nvmlDeviceGetComputeInstanceId = __library
            .get(b"nvmlDeviceGetComputeInstanceId\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMaxMigDeviceCount = __library
            .get(b"nvmlDeviceGetMaxMigDeviceCount\0")
            .map(|sym| *sym);
        let nvmlDeviceGetMigDeviceHandleByIndex = __library
            .get(b"nvmlDeviceGetMigDeviceHandleByIndex\0")
            .map(|sym| *sym);
        let nvmlDeviceGetDeviceHandleFromMigDeviceHandle = __library
            .get(b"nvmlDeviceGetDeviceHandleFromMigDeviceHandle\0")
            .map(|sym| *sym);
        let nvmlGpmMetricsGet = __library.get(b"nvmlGpmMetricsGet\0").map(|sym| *sym);
        let nvmlGpmSampleFree = __library.get(b"nvmlGpmSampleFree\0").map(|sym| *sym);
        let nvmlGpmSampleAlloc = __library.get(b"nvmlGpmSampleAlloc\0").map(|sym| *sym);
        let nvmlGpmSampleGet = __library.get(b"nvmlGpmSampleGet\0").map(|sym| *sym);
        let nvmlGpmMigSampleGet = __library.get(b"nvmlGpmMigSampleGet\0").map(|sym| *sym);
        let nvmlGpmQueryDeviceSupport = __library
            .get(b"nvmlGpmQueryDeviceSupport\0")
            .map(|sym| *sym);
        let nvmlGpmQueryIfStreamingEnabled = __library
            .get(b"nvmlGpmQueryIfStreamingEnabled\0")
            .map(|sym| *sym);
        let nvmlGpmSetStreamingEnabled = __library
            .get(b"nvmlGpmSetStreamingEnabled\0")
            .map(|sym| *sym);
        let nvmlDeviceSetNvLinkDeviceLowPowerThreshold = __library
            .get(b"nvmlDeviceSetNvLinkDeviceLowPowerThreshold\0")
            .map(|sym| *sym);
        let nvmlSystemSetNvlinkBwMode = __library
            .get(b"nvmlSystemSetNvlinkBwMode\0")
            .map(|sym| *sym);
        let nvmlSystemGetNvlinkBwMode = __library
            .get(b"nvmlSystemGetNvlinkBwMode\0")
            .map(|sym| *sym);
        let nvmlDeviceSetPowerManagementLimit_v2 = __library
            .get(b"nvmlDeviceSetPowerManagementLimit_v2\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlInit = __library.get(b"nvmlInit\0").map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetCount = __library.get(b"nvmlDeviceGetCount\0").map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetHandleByIndex = __library
            .get(b"nvmlDeviceGetHandleByIndex\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetHandleByPciBusId = __library
            .get(b"nvmlDeviceGetHandleByPciBusId\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetPciInfo = __library.get(b"nvmlDeviceGetPciInfo\0").map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetPciInfo_v2 = __library.get(b"nvmlDeviceGetPciInfo_v2\0").map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetNvLinkRemotePciInfo = __library
            .get(b"nvmlDeviceGetNvLinkRemotePciInfo\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetGridLicensableFeatures = __library
            .get(b"nvmlDeviceGetGridLicensableFeatures\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetGridLicensableFeatures_v2 = __library
            .get(b"nvmlDeviceGetGridLicensableFeatures_v2\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetGridLicensableFeatures_v3 = __library
            .get(b"nvmlDeviceGetGridLicensableFeatures_v3\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceRemoveGpu = __library.get(b"nvmlDeviceRemoveGpu\0").map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlEventSetWait = __library.get(b"nvmlEventSetWait\0").map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetAttributes = __library.get(b"nvmlDeviceGetAttributes\0").map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlComputeInstanceGetInfo = __library
            .get(b"nvmlComputeInstanceGetInfo\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetComputeRunningProcesses = __library
            .get(b"nvmlDeviceGetComputeRunningProcesses\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetComputeRunningProcesses_v2 = __library
            .get(b"nvmlDeviceGetComputeRunningProcesses_v2\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetGraphicsRunningProcesses = __library
            .get(b"nvmlDeviceGetGraphicsRunningProcesses\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetGraphicsRunningProcesses_v2 = __library
            .get(b"nvmlDeviceGetGraphicsRunningProcesses_v2\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetMPSComputeRunningProcesses = __library
            .get(b"nvmlDeviceGetMPSComputeRunningProcesses\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetMPSComputeRunningProcesses_v2 = __library
            .get(b"nvmlDeviceGetMPSComputeRunningProcesses_v2\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlDeviceGetGpuInstancePossiblePlacements = __library
            .get(b"nvmlDeviceGetGpuInstancePossiblePlacements\0")
            .map(|sym| *sym);
        #[cfg(feature = "legacy-functions")]
        let nvmlVgpuInstanceGetLicenseInfo = __library
            .get(b"nvmlVgpuInstanceGetLicenseInfo\0")
            .map(|sym| *sym);
        Ok(NvmlLib {
            __library,
            nvmlInit_v2,
            nvmlInitWithFlags,
            nvmlShutdown,
            nvmlErrorString,
            nvmlSystemGetDriverVersion,
            nvmlSystemGetNVMLVersion,
            nvmlSystemGetCudaDriverVersion,
            nvmlSystemGetCudaDriverVersion_v2,
            nvmlSystemGetProcessName,
            nvmlUnitGetCount,
            nvmlUnitGetHandleByIndex,
            nvmlUnitGetUnitInfo,
            nvmlUnitGetLedState,
            nvmlUnitGetPsuInfo,
            nvmlUnitGetTemperature,
            nvmlUnitGetFanSpeedInfo,
            nvmlUnitGetDevices,
            nvmlSystemGetHicVersion,
            nvmlDeviceGetCount_v2,
            nvmlDeviceGetAttributes_v2,
            nvmlDeviceGetHandleByIndex_v2,
            nvmlDeviceGetHandleBySerial,
            nvmlDeviceGetHandleByUUID,
            nvmlDeviceGetHandleByPciBusId_v2,
            nvmlDeviceGetName,
            nvmlDeviceGetBrand,
            nvmlDeviceGetIndex,
            nvmlDeviceGetSerial,
            nvmlDeviceGetModuleId,
            nvmlDeviceGetMemoryAffinity,
            nvmlDeviceGetCpuAffinityWithinScope,
            nvmlDeviceGetCpuAffinity,
            nvmlDeviceSetCpuAffinity,
            nvmlDeviceClearCpuAffinity,
            nvmlDeviceGetTopologyCommonAncestor,
            nvmlDeviceGetTopologyNearestGpus,
            nvmlSystemGetTopologyGpuSet,
            nvmlDeviceGetP2PStatus,
            nvmlDeviceGetUUID,
            nvmlVgpuInstanceGetMdevUUID,
            nvmlDeviceGetMinorNumber,
            nvmlDeviceGetBoardPartNumber,
            nvmlDeviceGetInforomVersion,
            nvmlDeviceGetInforomImageVersion,
            nvmlDeviceGetInforomConfigurationChecksum,
            nvmlDeviceValidateInforom,
            nvmlDeviceGetDisplayMode,
            nvmlDeviceGetDisplayActive,
            nvmlDeviceGetPersistenceMode,
            nvmlDeviceGetPciInfo_v3,
            nvmlDeviceGetMaxPcieLinkGeneration,
            nvmlDeviceGetGpuMaxPcieLinkGeneration,
            nvmlDeviceGetMaxPcieLinkWidth,
            nvmlDeviceGetCurrPcieLinkGeneration,
            nvmlDeviceGetCurrPcieLinkWidth,
            nvmlDeviceGetPcieThroughput,
            nvmlDeviceGetPcieReplayCounter,
            nvmlDeviceGetClockInfo,
            nvmlDeviceGetMaxClockInfo,
            nvmlDeviceGetGpcClkVfOffset,
            nvmlDeviceGetApplicationsClock,
            nvmlDeviceGetDefaultApplicationsClock,
            nvmlDeviceResetApplicationsClocks,
            nvmlDeviceGetClock,
            nvmlDeviceGetMaxCustomerBoostClock,
            nvmlDeviceGetSupportedMemoryClocks,
            nvmlDeviceGetSupportedGraphicsClocks,
            nvmlDeviceGetAutoBoostedClocksEnabled,
            nvmlDeviceSetAutoBoostedClocksEnabled,
            nvmlDeviceSetDefaultAutoBoostedClocksEnabled,
            nvmlDeviceGetFanSpeed,
            nvmlDeviceGetFanSpeed_v2,
            nvmlDeviceGetTargetFanSpeed,
            nvmlDeviceSetDefaultFanSpeed_v2,
            nvmlDeviceGetMinMaxFanSpeed,
            nvmlDeviceGetFanControlPolicy_v2,
            nvmlDeviceSetFanControlPolicy,
            nvmlDeviceGetNumFans,
            nvmlDeviceGetTemperature,
            nvmlDeviceGetTemperatureThreshold,
            nvmlDeviceSetTemperatureThreshold,
            nvmlDeviceGetThermalSettings,
            nvmlDeviceGetPerformanceState,
            nvmlDeviceGetCurrentClocksEventReasons,
            nvmlDeviceGetCurrentClocksThrottleReasons,
            nvmlDeviceGetSupportedClocksEventReasons,
            nvmlDeviceGetSupportedClocksThrottleReasons,
            nvmlDeviceGetPowerState,
            nvmlDeviceGetDynamicPstatesInfo,
            nvmlDeviceGetMemClkVfOffset,
            nvmlDeviceGetMinMaxClockOfPState,
            nvmlDeviceGetSupportedPerformanceStates,
            nvmlDeviceGetGpcClkMinMaxVfOffset,
            nvmlDeviceGetMemClkMinMaxVfOffset,
            nvmlDeviceGetPowerManagementMode,
            nvmlDeviceGetPowerManagementLimit,
            nvmlDeviceGetPowerManagementLimitConstraints,
            nvmlDeviceGetPowerManagementDefaultLimit,
            nvmlDeviceGetPowerUsage,
            nvmlDeviceGetTotalEnergyConsumption,
            nvmlDeviceGetEnforcedPowerLimit,
            nvmlDeviceGetGpuOperationMode,
            nvmlDeviceGetMemoryInfo,
            nvmlDeviceGetMemoryInfo_v2,
            nvmlDeviceGetComputeMode,
            nvmlDeviceGetCudaComputeCapability,
            nvmlDeviceGetEccMode,
            nvmlDeviceGetDefaultEccMode,
            nvmlDeviceGetBoardId,
            nvmlDeviceGetMultiGpuBoard,
            nvmlDeviceGetTotalEccErrors,
            nvmlDeviceGetDetailedEccErrors,
            nvmlDeviceGetMemoryErrorCounter,
            nvmlDeviceGetUtilizationRates,
            nvmlDeviceGetEncoderUtilization,
            nvmlDeviceGetEncoderCapacity,
            nvmlDeviceGetEncoderStats,
            nvmlDeviceGetEncoderSessions,
            nvmlDeviceGetDecoderUtilization,
            nvmlDeviceGetJpgUtilization,
            nvmlDeviceGetOfaUtilization,
            nvmlDeviceGetFBCStats,
            nvmlDeviceGetFBCSessions,
            nvmlDeviceGetDriverModel,
            nvmlDeviceGetVbiosVersion,
            nvmlDeviceGetBridgeChipInfo,
            nvmlDeviceGetComputeRunningProcesses_v3,
            nvmlDeviceGetGraphicsRunningProcesses_v3,
            nvmlDeviceGetMPSComputeRunningProcesses_v3,
            nvmlDeviceGetRunningProcessDetailList,
            nvmlDeviceOnSameBoard,
            nvmlDeviceGetAPIRestriction,
            nvmlDeviceGetSamples,
            nvmlDeviceGetBAR1MemoryInfo,
            nvmlDeviceGetViolationStatus,
            nvmlDeviceGetIrqNum,
            nvmlDeviceGetNumGpuCores,
            nvmlDeviceGetPowerSource,
            nvmlDeviceGetMemoryBusWidth,
            nvmlDeviceGetPcieLinkMaxSpeed,
            nvmlDeviceGetPcieSpeed,
            nvmlDeviceGetAdaptiveClockInfoStatus,
            nvmlDeviceGetBusType,
            nvmlDeviceGetGpuFabricInfo,
            nvmlSystemGetConfComputeCapabilities,
            nvmlSystemGetConfComputeState,
            nvmlDeviceGetConfComputeMemSizeInfo,
            nvmlSystemGetConfComputeGpusReadyState,
            nvmlDeviceGetConfComputeProtectedMemoryUsage,
            nvmlDeviceGetConfComputeGpuCertificate,
            nvmlDeviceGetConfComputeGpuAttestationReport,
            nvmlDeviceGetAccountingMode,
            nvmlDeviceGetAccountingStats,
            nvmlDeviceGetAccountingPids,
            nvmlDeviceGetAccountingBufferSize,
            nvmlDeviceGetRetiredPages,
            nvmlDeviceGetRetiredPages_v2,
            nvmlDeviceGetRetiredPagesPendingStatus,
            nvmlDeviceGetRemappedRows,
            nvmlDeviceGetRowRemapperHistogram,
            nvmlDeviceGetArchitecture,
            nvmlUnitSetLedState,
            nvmlDeviceSetPersistenceMode,
            nvmlDeviceSetComputeMode,
            nvmlDeviceSetEccMode,
            nvmlDeviceClearEccErrorCounts,
            nvmlDeviceSetDriverModel,
            nvmlDeviceSetGpuLockedClocks,
            nvmlDeviceResetGpuLockedClocks,
            nvmlDeviceSetMemoryLockedClocks,
            nvmlDeviceResetMemoryLockedClocks,
            nvmlDeviceSetApplicationsClocks,
            nvmlDeviceGetClkMonStatus,
            nvmlDeviceSetPowerManagementLimit,
            nvmlDeviceSetGpuOperationMode,
            nvmlDeviceSetAPIRestriction,
            nvmlDeviceSetFanSpeed_v2,
            nvmlDeviceSetGpcClkVfOffset,
            nvmlDeviceSetMemClkVfOffset,
            nvmlDeviceSetConfComputeUnprotectedMemSize,
            nvmlSystemSetConfComputeGpusReadyState,
            nvmlDeviceSetAccountingMode,
            nvmlDeviceClearAccountingPids,
            nvmlDeviceGetNvLinkState,
            nvmlDeviceGetNvLinkVersion,
            nvmlDeviceGetNvLinkCapability,
            nvmlDeviceGetNvLinkRemotePciInfo_v2,
            nvmlDeviceGetNvLinkErrorCounter,
            nvmlDeviceResetNvLinkErrorCounters,
            nvmlDeviceSetNvLinkUtilizationControl,
            nvmlDeviceGetNvLinkUtilizationControl,
            nvmlDeviceGetNvLinkUtilizationCounter,
            nvmlDeviceFreezeNvLinkUtilizationCounter,
            nvmlDeviceResetNvLinkUtilizationCounter,
            nvmlDeviceGetNvLinkRemoteDeviceType,
            nvmlEventSetCreate,
            nvmlDeviceRegisterEvents,
            nvmlDeviceGetSupportedEventTypes,
            nvmlEventSetWait_v2,
            nvmlEventSetFree,
            nvmlDeviceModifyDrainState,
            nvmlDeviceQueryDrainState,
            nvmlDeviceRemoveGpu_v2,
            nvmlDeviceDiscoverGpus,
            nvmlDeviceGetFieldValues,
            nvmlDeviceClearFieldValues,
            nvmlDeviceGetVirtualizationMode,
            nvmlDeviceGetHostVgpuMode,
            nvmlDeviceSetVirtualizationMode,
            nvmlDeviceGetGridLicensableFeatures_v4,
            nvmlDeviceGetProcessUtilization,
            nvmlDeviceGetGspFirmwareVersion,
            nvmlDeviceGetGspFirmwareMode,
            nvmlGetVgpuDriverCapabilities,
            nvmlDeviceGetVgpuCapabilities,
            nvmlDeviceGetSupportedVgpus,
            nvmlDeviceGetCreatableVgpus,
            nvmlVgpuTypeGetClass,
            nvmlVgpuTypeGetName,
            nvmlVgpuTypeGetGpuInstanceProfileId,
            nvmlVgpuTypeGetDeviceID,
            nvmlVgpuTypeGetFramebufferSize,
            nvmlVgpuTypeGetNumDisplayHeads,
            nvmlVgpuTypeGetResolution,
            nvmlVgpuTypeGetLicense,
            nvmlVgpuTypeGetFrameRateLimit,
            nvmlVgpuTypeGetMaxInstances,
            nvmlVgpuTypeGetMaxInstancesPerVm,
            nvmlDeviceGetActiveVgpus,
            nvmlVgpuInstanceGetVmID,
            nvmlVgpuInstanceGetUUID,
            nvmlVgpuInstanceGetVmDriverVersion,
            nvmlVgpuInstanceGetFbUsage,
            nvmlVgpuInstanceGetLicenseStatus,
            nvmlVgpuInstanceGetType,
            nvmlVgpuInstanceGetFrameRateLimit,
            nvmlVgpuInstanceGetEccMode,
            nvmlVgpuInstanceGetEncoderCapacity,
            nvmlVgpuInstanceSetEncoderCapacity,
            nvmlVgpuInstanceGetEncoderStats,
            nvmlVgpuInstanceGetEncoderSessions,
            nvmlVgpuInstanceGetFBCStats,
            nvmlVgpuInstanceGetFBCSessions,
            nvmlVgpuInstanceGetGpuInstanceId,
            nvmlVgpuInstanceGetGpuPciId,
            nvmlVgpuTypeGetCapabilities,
            nvmlVgpuInstanceGetMetadata,
            nvmlDeviceGetVgpuMetadata,
            nvmlGetVgpuCompatibility,
            nvmlDeviceGetPgpuMetadataString,
            nvmlDeviceGetVgpuSchedulerLog,
            nvmlDeviceGetVgpuSchedulerState,
            nvmlDeviceGetVgpuSchedulerCapabilities,
            nvmlDeviceSetVgpuSchedulerState,
            nvmlGetVgpuVersion,
            nvmlSetVgpuVersion,
            nvmlDeviceGetVgpuUtilization,
            nvmlDeviceGetVgpuProcessUtilization,
            nvmlVgpuInstanceGetAccountingMode,
            nvmlVgpuInstanceGetAccountingPids,
            nvmlVgpuInstanceGetAccountingStats,
            nvmlVgpuInstanceClearAccountingPids,
            nvmlVgpuInstanceGetLicenseInfo_v2,
            nvmlGetExcludedDeviceCount,
            nvmlGetExcludedDeviceInfoByIndex,
            nvmlDeviceSetMigMode,
            nvmlDeviceGetMigMode,
            nvmlDeviceGetGpuInstanceProfileInfo,
            nvmlDeviceGetGpuInstanceProfileInfoV,
            nvmlDeviceGetGpuInstancePossiblePlacements_v2,
            nvmlDeviceGetGpuInstanceRemainingCapacity,
            nvmlDeviceCreateGpuInstance,
            nvmlDeviceCreateGpuInstanceWithPlacement,
            nvmlGpuInstanceDestroy,
            nvmlDeviceGetGpuInstances,
            nvmlDeviceGetGpuInstanceById,
            nvmlGpuInstanceGetInfo,
            nvmlGpuInstanceGetComputeInstanceProfileInfo,
            nvmlGpuInstanceGetComputeInstanceProfileInfoV,
            nvmlGpuInstanceGetComputeInstanceRemainingCapacity,
            nvmlGpuInstanceGetComputeInstancePossiblePlacements,
            nvmlGpuInstanceCreateComputeInstance,
            nvmlGpuInstanceCreateComputeInstanceWithPlacement,
            nvmlComputeInstanceDestroy,
            nvmlGpuInstanceGetComputeInstances,
            nvmlGpuInstanceGetComputeInstanceById,
            nvmlComputeInstanceGetInfo_v2,
            nvmlDeviceIsMigDeviceHandle,
            nvmlDeviceGetGpuInstanceId,
            nvmlDeviceGetComputeInstanceId,
            nvmlDeviceGetMaxMigDeviceCount,
            nvmlDeviceGetMigDeviceHandleByIndex,
            nvmlDeviceGetDeviceHandleFromMigDeviceHandle,
            nvmlGpmMetricsGet,
            nvmlGpmSampleFree,
            nvmlGpmSampleAlloc,
            nvmlGpmSampleGet,
            nvmlGpmMigSampleGet,
            nvmlGpmQueryDeviceSupport,
            nvmlGpmQueryIfStreamingEnabled,
            nvmlGpmSetStreamingEnabled,
            nvmlDeviceSetNvLinkDeviceLowPowerThreshold,
            nvmlSystemSetNvlinkBwMode,
            nvmlSystemGetNvlinkBwMode,
            nvmlDeviceSetPowerManagementLimit_v2,
            #[cfg(feature = "legacy-functions")]
            nvmlInit,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetCount,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetHandleByIndex,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetHandleByPciBusId,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetPciInfo,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetPciInfo_v2,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetNvLinkRemotePciInfo,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetGridLicensableFeatures,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetGridLicensableFeatures_v2,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetGridLicensableFeatures_v3,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceRemoveGpu,
            #[cfg(feature = "legacy-functions")]
            nvmlEventSetWait,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetAttributes,
            #[cfg(feature = "legacy-functions")]
            nvmlComputeInstanceGetInfo,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetComputeRunningProcesses,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetComputeRunningProcesses_v2,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetGraphicsRunningProcesses,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetGraphicsRunningProcesses_v2,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetMPSComputeRunningProcesses,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetMPSComputeRunningProcesses_v2,
            #[cfg(feature = "legacy-functions")]
            nvmlDeviceGetGpuInstancePossiblePlacements,
            #[cfg(feature = "legacy-functions")]
            nvmlVgpuInstanceGetLicenseInfo,
        })
    }
    pub unsafe fn nvmlInit_v2(&self) -> nvmlReturn_t {
        (self
            .nvmlInit_v2
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn nvmlInitWithFlags(&self, flags: raw::c_uint) -> nvmlReturn_t {
        (self
            .nvmlInitWithFlags
            .as_ref()
            .expect("Expected function, got error."))(flags)
    }
    pub unsafe fn nvmlShutdown(&self) -> nvmlReturn_t {
        (self
            .nvmlShutdown
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn nvmlErrorString(&self, result: nvmlReturn_t) -> *const raw::c_char {
        (self
            .nvmlErrorString
            .as_ref()
            .expect("Expected function, got error."))(result)
    }
    pub unsafe fn nvmlSystemGetDriverVersion(
        &self,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetDriverVersion
            .as_ref()
            .expect("Expected function, got error."))(version, length)
    }
    pub unsafe fn nvmlSystemGetNVMLVersion(
        &self,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetNVMLVersion
            .as_ref()
            .expect("Expected function, got error."))(version, length)
    }
    pub unsafe fn nvmlSystemGetCudaDriverVersion(
        &self,
        cudaDriverVersion: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetCudaDriverVersion
            .as_ref()
            .expect("Expected function, got error."))(cudaDriverVersion)
    }
    pub unsafe fn nvmlSystemGetCudaDriverVersion_v2(
        &self,
        cudaDriverVersion: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetCudaDriverVersion_v2
            .as_ref()
            .expect("Expected function, got error."))(cudaDriverVersion)
    }
    pub unsafe fn nvmlSystemGetProcessName(
        &self,
        pid: raw::c_uint,
        name: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetProcessName
            .as_ref()
            .expect("Expected function, got error."))(pid, name, length)
    }
    pub unsafe fn nvmlUnitGetCount(&self, unitCount: *mut raw::c_uint) -> nvmlReturn_t {
        (self
            .nvmlUnitGetCount
            .as_ref()
            .expect("Expected function, got error."))(unitCount)
    }
    pub unsafe fn nvmlUnitGetHandleByIndex(
        &self,
        index: raw::c_uint,
        unit: *mut nvmlUnit_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetHandleByIndex
            .as_ref()
            .expect("Expected function, got error."))(index, unit)
    }
    pub unsafe fn nvmlUnitGetUnitInfo(
        &self,
        unit: nvmlUnit_t,
        info: *mut nvmlUnitInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetUnitInfo
            .as_ref()
            .expect("Expected function, got error."))(unit, info)
    }
    pub unsafe fn nvmlUnitGetLedState(
        &self,
        unit: nvmlUnit_t,
        state: *mut nvmlLedState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetLedState
            .as_ref()
            .expect("Expected function, got error."))(unit, state)
    }
    pub unsafe fn nvmlUnitGetPsuInfo(
        &self,
        unit: nvmlUnit_t,
        psu: *mut nvmlPSUInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetPsuInfo
            .as_ref()
            .expect("Expected function, got error."))(unit, psu)
    }
    pub unsafe fn nvmlUnitGetTemperature(
        &self,
        unit: nvmlUnit_t,
        type_: raw::c_uint,
        temp: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetTemperature
            .as_ref()
            .expect("Expected function, got error."))(unit, type_, temp)
    }
    pub unsafe fn nvmlUnitGetFanSpeedInfo(
        &self,
        unit: nvmlUnit_t,
        fanSpeeds: *mut nvmlUnitFanSpeeds_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetFanSpeedInfo
            .as_ref()
            .expect("Expected function, got error."))(unit, fanSpeeds)
    }
    pub unsafe fn nvmlUnitGetDevices(
        &self,
        unit: nvmlUnit_t,
        deviceCount: *mut raw::c_uint,
        devices: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitGetDevices
            .as_ref()
            .expect("Expected function, got error."))(unit, deviceCount, devices)
    }
    pub unsafe fn nvmlSystemGetHicVersion(
        &self,
        hwbcCount: *mut raw::c_uint,
        hwbcEntries: *mut nvmlHwbcEntry_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetHicVersion
            .as_ref()
            .expect("Expected function, got error."))(hwbcCount, hwbcEntries)
    }
    pub unsafe fn nvmlDeviceGetCount_v2(&self, deviceCount: *mut raw::c_uint) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCount_v2
            .as_ref()
            .expect("Expected function, got error."))(deviceCount)
    }
    pub unsafe fn nvmlDeviceGetAttributes_v2(
        &self,
        device: nvmlDevice_t,
        attributes: *mut nvmlDeviceAttributes_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAttributes_v2
            .as_ref()
            .expect("Expected function, got error."))(device, attributes)
    }
    pub unsafe fn nvmlDeviceGetHandleByIndex_v2(
        &self,
        index: raw::c_uint,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHandleByIndex_v2
            .as_ref()
            .expect("Expected function, got error."))(index, device)
    }
    pub unsafe fn nvmlDeviceGetHandleBySerial(
        &self,
        serial: *const raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHandleBySerial
            .as_ref()
            .expect("Expected function, got error."))(serial, device)
    }
    pub unsafe fn nvmlDeviceGetHandleByUUID(
        &self,
        uuid: *const raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHandleByUUID
            .as_ref()
            .expect("Expected function, got error."))(uuid, device)
    }
    pub unsafe fn nvmlDeviceGetHandleByPciBusId_v2(
        &self,
        pciBusId: *const raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHandleByPciBusId_v2
            .as_ref()
            .expect("Expected function, got error."))(pciBusId, device)
    }
    pub unsafe fn nvmlDeviceGetName(
        &self,
        device: nvmlDevice_t,
        name: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetName
            .as_ref()
            .expect("Expected function, got error."))(device, name, length)
    }
    pub unsafe fn nvmlDeviceGetBrand(
        &self,
        device: nvmlDevice_t,
        type_: *mut nvmlBrandType_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBrand
            .as_ref()
            .expect("Expected function, got error."))(device, type_)
    }
    pub unsafe fn nvmlDeviceGetIndex(
        &self,
        device: nvmlDevice_t,
        index: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetIndex
            .as_ref()
            .expect("Expected function, got error."))(device, index)
    }
    pub unsafe fn nvmlDeviceGetSerial(
        &self,
        device: nvmlDevice_t,
        serial: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSerial
            .as_ref()
            .expect("Expected function, got error."))(device, serial, length)
    }
    pub unsafe fn nvmlDeviceGetModuleId(
        &self,
        device: nvmlDevice_t,
        moduleId: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetModuleId
            .as_ref()
            .expect("Expected function, got error."))(device, moduleId)
    }
    pub unsafe fn nvmlDeviceGetMemoryAffinity(
        &self,
        device: nvmlDevice_t,
        nodeSetSize: raw::c_uint,
        nodeSet: *mut raw::c_ulong,
        scope: nvmlAffinityScope_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMemoryAffinity
            .as_ref()
            .expect("Expected function, got error."))(device, nodeSetSize, nodeSet, scope)
    }
    pub unsafe fn nvmlDeviceGetCpuAffinityWithinScope(
        &self,
        device: nvmlDevice_t,
        cpuSetSize: raw::c_uint,
        cpuSet: *mut raw::c_ulong,
        scope: nvmlAffinityScope_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCpuAffinityWithinScope
            .as_ref()
            .expect("Expected function, got error."))(device, cpuSetSize, cpuSet, scope)
    }
    pub unsafe fn nvmlDeviceGetCpuAffinity(
        &self,
        device: nvmlDevice_t,
        cpuSetSize: raw::c_uint,
        cpuSet: *mut raw::c_ulong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCpuAffinity
            .as_ref()
            .expect("Expected function, got error."))(device, cpuSetSize, cpuSet)
    }
    pub unsafe fn nvmlDeviceSetCpuAffinity(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetCpuAffinity
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceClearCpuAffinity(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceClearCpuAffinity
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceGetTopologyCommonAncestor(
        &self,
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        pathInfo: *mut nvmlGpuTopologyLevel_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTopologyCommonAncestor
            .as_ref()
            .expect("Expected function, got error."))(device1, device2, pathInfo)
    }
    pub unsafe fn nvmlDeviceGetTopologyNearestGpus(
        &self,
        device: nvmlDevice_t,
        level: nvmlGpuTopologyLevel_t,
        count: *mut raw::c_uint,
        deviceArray: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTopologyNearestGpus
            .as_ref()
            .expect("Expected function, got error."))(device, level, count, deviceArray)
    }
    pub unsafe fn nvmlSystemGetTopologyGpuSet(
        &self,
        cpuNumber: raw::c_uint,
        count: *mut raw::c_uint,
        deviceArray: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetTopologyGpuSet
            .as_ref()
            .expect("Expected function, got error."))(cpuNumber, count, deviceArray)
    }
    pub unsafe fn nvmlDeviceGetP2PStatus(
        &self,
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        p2pIndex: nvmlGpuP2PCapsIndex_t,
        p2pStatus: *mut nvmlGpuP2PStatus_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetP2PStatus
            .as_ref()
            .expect("Expected function, got error."))(device1, device2, p2pIndex, p2pStatus)
    }
    pub unsafe fn nvmlDeviceGetUUID(
        &self,
        device: nvmlDevice_t,
        uuid: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetUUID
            .as_ref()
            .expect("Expected function, got error."))(device, uuid, length)
    }
    pub unsafe fn nvmlVgpuInstanceGetMdevUUID(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        mdevUuid: *mut raw::c_char,
        size: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetMdevUUID
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, mdevUuid, size)
    }
    pub unsafe fn nvmlDeviceGetMinorNumber(
        &self,
        device: nvmlDevice_t,
        minorNumber: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMinorNumber
            .as_ref()
            .expect("Expected function, got error."))(device, minorNumber)
    }
    pub unsafe fn nvmlDeviceGetBoardPartNumber(
        &self,
        device: nvmlDevice_t,
        partNumber: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBoardPartNumber
            .as_ref()
            .expect("Expected function, got error."))(device, partNumber, length)
    }
    pub unsafe fn nvmlDeviceGetInforomVersion(
        &self,
        device: nvmlDevice_t,
        object: nvmlInforomObject_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetInforomVersion
            .as_ref()
            .expect("Expected function, got error."))(device, object, version, length)
    }
    pub unsafe fn nvmlDeviceGetInforomImageVersion(
        &self,
        device: nvmlDevice_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetInforomImageVersion
            .as_ref()
            .expect("Expected function, got error."))(device, version, length)
    }
    pub unsafe fn nvmlDeviceGetInforomConfigurationChecksum(
        &self,
        device: nvmlDevice_t,
        checksum: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetInforomConfigurationChecksum
            .as_ref()
            .expect("Expected function, got error."))(device, checksum)
    }
    pub unsafe fn nvmlDeviceValidateInforom(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceValidateInforom
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceGetDisplayMode(
        &self,
        device: nvmlDevice_t,
        display: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDisplayMode
            .as_ref()
            .expect("Expected function, got error."))(device, display)
    }
    pub unsafe fn nvmlDeviceGetDisplayActive(
        &self,
        device: nvmlDevice_t,
        isActive: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDisplayActive
            .as_ref()
            .expect("Expected function, got error."))(device, isActive)
    }
    pub unsafe fn nvmlDeviceGetPersistenceMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPersistenceMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceGetPciInfo_v3(
        &self,
        device: nvmlDevice_t,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPciInfo_v3
            .as_ref()
            .expect("Expected function, got error."))(device, pci)
    }
    pub unsafe fn nvmlDeviceGetMaxPcieLinkGeneration(
        &self,
        device: nvmlDevice_t,
        maxLinkGen: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMaxPcieLinkGeneration
            .as_ref()
            .expect("Expected function, got error."))(device, maxLinkGen)
    }
    pub unsafe fn nvmlDeviceGetGpuMaxPcieLinkGeneration(
        &self,
        device: nvmlDevice_t,
        maxLinkGenDevice: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuMaxPcieLinkGeneration
            .as_ref()
            .expect("Expected function, got error."))(device, maxLinkGenDevice)
    }
    pub unsafe fn nvmlDeviceGetMaxPcieLinkWidth(
        &self,
        device: nvmlDevice_t,
        maxLinkWidth: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMaxPcieLinkWidth
            .as_ref()
            .expect("Expected function, got error."))(device, maxLinkWidth)
    }
    pub unsafe fn nvmlDeviceGetCurrPcieLinkGeneration(
        &self,
        device: nvmlDevice_t,
        currLinkGen: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCurrPcieLinkGeneration
            .as_ref()
            .expect("Expected function, got error."))(device, currLinkGen)
    }
    pub unsafe fn nvmlDeviceGetCurrPcieLinkWidth(
        &self,
        device: nvmlDevice_t,
        currLinkWidth: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCurrPcieLinkWidth
            .as_ref()
            .expect("Expected function, got error."))(device, currLinkWidth)
    }
    pub unsafe fn nvmlDeviceGetPcieThroughput(
        &self,
        device: nvmlDevice_t,
        counter: nvmlPcieUtilCounter_t,
        value: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPcieThroughput
            .as_ref()
            .expect("Expected function, got error."))(device, counter, value)
    }
    pub unsafe fn nvmlDeviceGetPcieReplayCounter(
        &self,
        device: nvmlDevice_t,
        value: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPcieReplayCounter
            .as_ref()
            .expect("Expected function, got error."))(device, value)
    }
    pub unsafe fn nvmlDeviceGetClockInfo(
        &self,
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        clock: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetClockInfo
            .as_ref()
            .expect("Expected function, got error."))(device, type_, clock)
    }
    pub unsafe fn nvmlDeviceGetMaxClockInfo(
        &self,
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        clock: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMaxClockInfo
            .as_ref()
            .expect("Expected function, got error."))(device, type_, clock)
    }
    pub unsafe fn nvmlDeviceGetGpcClkVfOffset(
        &self,
        device: nvmlDevice_t,
        offset: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpcClkVfOffset
            .as_ref()
            .expect("Expected function, got error."))(device, offset)
    }
    pub unsafe fn nvmlDeviceGetApplicationsClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetApplicationsClock
            .as_ref()
            .expect("Expected function, got error."))(device, clockType, clockMHz)
    }
    pub unsafe fn nvmlDeviceGetDefaultApplicationsClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDefaultApplicationsClock
            .as_ref()
            .expect("Expected function, got error."))(device, clockType, clockMHz)
    }
    pub unsafe fn nvmlDeviceResetApplicationsClocks(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceResetApplicationsClocks
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceGetClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockId: nvmlClockId_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetClock
            .as_ref()
            .expect("Expected function, got error."))(device, clockType, clockId, clockMHz)
    }
    pub unsafe fn nvmlDeviceGetMaxCustomerBoostClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMaxCustomerBoostClock
            .as_ref()
            .expect("Expected function, got error."))(device, clockType, clockMHz)
    }
    pub unsafe fn nvmlDeviceGetSupportedMemoryClocks(
        &self,
        device: nvmlDevice_t,
        count: *mut raw::c_uint,
        clocksMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedMemoryClocks
            .as_ref()
            .expect("Expected function, got error."))(device, count, clocksMHz)
    }
    pub unsafe fn nvmlDeviceGetSupportedGraphicsClocks(
        &self,
        device: nvmlDevice_t,
        memoryClockMHz: raw::c_uint,
        count: *mut raw::c_uint,
        clocksMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedGraphicsClocks
            .as_ref()
            .expect("Expected function, got error."))(
            device, memoryClockMHz, count, clocksMHz
        )
    }
    pub unsafe fn nvmlDeviceGetAutoBoostedClocksEnabled(
        &self,
        device: nvmlDevice_t,
        isEnabled: *mut nvmlEnableState_t,
        defaultIsEnabled: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAutoBoostedClocksEnabled
            .as_ref()
            .expect("Expected function, got error."))(device, isEnabled, defaultIsEnabled)
    }
    pub unsafe fn nvmlDeviceSetAutoBoostedClocksEnabled(
        &self,
        device: nvmlDevice_t,
        enabled: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetAutoBoostedClocksEnabled
            .as_ref()
            .expect("Expected function, got error."))(device, enabled)
    }
    pub unsafe fn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(
        &self,
        device: nvmlDevice_t,
        enabled: nvmlEnableState_t,
        flags: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetDefaultAutoBoostedClocksEnabled
            .as_ref()
            .expect("Expected function, got error."))(device, enabled, flags)
    }
    pub unsafe fn nvmlDeviceGetFanSpeed(
        &self,
        device: nvmlDevice_t,
        speed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFanSpeed
            .as_ref()
            .expect("Expected function, got error."))(device, speed)
    }
    pub unsafe fn nvmlDeviceGetFanSpeed_v2(
        &self,
        device: nvmlDevice_t,
        fan: raw::c_uint,
        speed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFanSpeed_v2
            .as_ref()
            .expect("Expected function, got error."))(device, fan, speed)
    }
    pub unsafe fn nvmlDeviceGetTargetFanSpeed(
        &self,
        device: nvmlDevice_t,
        fan: raw::c_uint,
        targetSpeed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTargetFanSpeed
            .as_ref()
            .expect("Expected function, got error."))(device, fan, targetSpeed)
    }
    pub unsafe fn nvmlDeviceSetDefaultFanSpeed_v2(
        &self,
        device: nvmlDevice_t,
        fan: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetDefaultFanSpeed_v2
            .as_ref()
            .expect("Expected function, got error."))(device, fan)
    }
    pub unsafe fn nvmlDeviceGetMinMaxFanSpeed(
        &self,
        device: nvmlDevice_t,
        minSpeed: *mut raw::c_uint,
        maxSpeed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMinMaxFanSpeed
            .as_ref()
            .expect("Expected function, got error."))(device, minSpeed, maxSpeed)
    }
    pub unsafe fn nvmlDeviceGetFanControlPolicy_v2(
        &self,
        device: nvmlDevice_t,
        fan: raw::c_uint,
        policy: *mut nvmlFanControlPolicy_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFanControlPolicy_v2
            .as_ref()
            .expect("Expected function, got error."))(device, fan, policy)
    }
    pub unsafe fn nvmlDeviceSetFanControlPolicy(
        &self,
        device: nvmlDevice_t,
        fan: raw::c_uint,
        policy: nvmlFanControlPolicy_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetFanControlPolicy
            .as_ref()
            .expect("Expected function, got error."))(device, fan, policy)
    }
    pub unsafe fn nvmlDeviceGetNumFans(
        &self,
        device: nvmlDevice_t,
        numFans: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNumFans
            .as_ref()
            .expect("Expected function, got error."))(device, numFans)
    }
    pub unsafe fn nvmlDeviceGetTemperature(
        &self,
        device: nvmlDevice_t,
        sensorType: nvmlTemperatureSensors_t,
        temp: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTemperature
            .as_ref()
            .expect("Expected function, got error."))(device, sensorType, temp)
    }
    pub unsafe fn nvmlDeviceGetTemperatureThreshold(
        &self,
        device: nvmlDevice_t,
        thresholdType: nvmlTemperatureThresholds_t,
        temp: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTemperatureThreshold
            .as_ref()
            .expect("Expected function, got error."))(device, thresholdType, temp)
    }
    pub unsafe fn nvmlDeviceSetTemperatureThreshold(
        &self,
        device: nvmlDevice_t,
        thresholdType: nvmlTemperatureThresholds_t,
        temp: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetTemperatureThreshold
            .as_ref()
            .expect("Expected function, got error."))(device, thresholdType, temp)
    }
    pub unsafe fn nvmlDeviceGetThermalSettings(
        &self,
        device: nvmlDevice_t,
        sensorIndex: raw::c_uint,
        pThermalSettings: *mut nvmlGpuThermalSettings_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetThermalSettings
            .as_ref()
            .expect("Expected function, got error."))(device, sensorIndex, pThermalSettings)
    }
    pub unsafe fn nvmlDeviceGetPerformanceState(
        &self,
        device: nvmlDevice_t,
        pState: *mut nvmlPstates_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPerformanceState
            .as_ref()
            .expect("Expected function, got error."))(device, pState)
    }
    pub unsafe fn nvmlDeviceGetCurrentClocksEventReasons(
        &self,
        device: nvmlDevice_t,
        clocksEventReasons: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCurrentClocksEventReasons
            .as_ref()
            .expect("Expected function, got error."))(device, clocksEventReasons)
    }
    pub unsafe fn nvmlDeviceGetCurrentClocksThrottleReasons(
        &self,
        device: nvmlDevice_t,
        clocksThrottleReasons: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCurrentClocksThrottleReasons
            .as_ref()
            .expect("Expected function, got error."))(device, clocksThrottleReasons)
    }
    pub unsafe fn nvmlDeviceGetSupportedClocksEventReasons(
        &self,
        device: nvmlDevice_t,
        supportedClocksEventReasons: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedClocksEventReasons
            .as_ref()
            .expect("Expected function, got error."))(device, supportedClocksEventReasons)
    }
    pub unsafe fn nvmlDeviceGetSupportedClocksThrottleReasons(
        &self,
        device: nvmlDevice_t,
        supportedClocksThrottleReasons: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedClocksThrottleReasons
            .as_ref()
            .expect("Expected function, got error."))(device, supportedClocksThrottleReasons)
    }
    pub unsafe fn nvmlDeviceGetPowerState(
        &self,
        device: nvmlDevice_t,
        pState: *mut nvmlPstates_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerState
            .as_ref()
            .expect("Expected function, got error."))(device, pState)
    }
    pub unsafe fn nvmlDeviceGetDynamicPstatesInfo(
        &self,
        device: nvmlDevice_t,
        pDynamicPstatesInfo: *mut nvmlGpuDynamicPstatesInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDynamicPstatesInfo
            .as_ref()
            .expect("Expected function, got error."))(device, pDynamicPstatesInfo)
    }
    pub unsafe fn nvmlDeviceGetMemClkVfOffset(
        &self,
        device: nvmlDevice_t,
        offset: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMemClkVfOffset
            .as_ref()
            .expect("Expected function, got error."))(device, offset)
    }
    pub unsafe fn nvmlDeviceGetMinMaxClockOfPState(
        &self,
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        pstate: nvmlPstates_t,
        minClockMHz: *mut raw::c_uint,
        maxClockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMinMaxClockOfPState
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            type_,
            pstate,
            minClockMHz,
            maxClockMHz,
        )
    }
    pub unsafe fn nvmlDeviceGetSupportedPerformanceStates(
        &self,
        device: nvmlDevice_t,
        pstates: *mut nvmlPstates_t,
        size: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedPerformanceStates
            .as_ref()
            .expect("Expected function, got error."))(device, pstates, size)
    }
    pub unsafe fn nvmlDeviceGetGpcClkMinMaxVfOffset(
        &self,
        device: nvmlDevice_t,
        minOffset: *mut raw::c_int,
        maxOffset: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpcClkMinMaxVfOffset
            .as_ref()
            .expect("Expected function, got error."))(device, minOffset, maxOffset)
    }
    pub unsafe fn nvmlDeviceGetMemClkMinMaxVfOffset(
        &self,
        device: nvmlDevice_t,
        minOffset: *mut raw::c_int,
        maxOffset: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMemClkMinMaxVfOffset
            .as_ref()
            .expect("Expected function, got error."))(device, minOffset, maxOffset)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerManagementMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementLimit(
        &self,
        device: nvmlDevice_t,
        limit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerManagementLimit
            .as_ref()
            .expect("Expected function, got error."))(device, limit)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementLimitConstraints(
        &self,
        device: nvmlDevice_t,
        minLimit: *mut raw::c_uint,
        maxLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerManagementLimitConstraints
            .as_ref()
            .expect("Expected function, got error."))(device, minLimit, maxLimit)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementDefaultLimit(
        &self,
        device: nvmlDevice_t,
        defaultLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerManagementDefaultLimit
            .as_ref()
            .expect("Expected function, got error."))(device, defaultLimit)
    }
    pub unsafe fn nvmlDeviceGetPowerUsage(
        &self,
        device: nvmlDevice_t,
        power: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerUsage
            .as_ref()
            .expect("Expected function, got error."))(device, power)
    }
    pub unsafe fn nvmlDeviceGetTotalEnergyConsumption(
        &self,
        device: nvmlDevice_t,
        energy: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTotalEnergyConsumption
            .as_ref()
            .expect("Expected function, got error."))(device, energy)
    }
    pub unsafe fn nvmlDeviceGetEnforcedPowerLimit(
        &self,
        device: nvmlDevice_t,
        limit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEnforcedPowerLimit
            .as_ref()
            .expect("Expected function, got error."))(device, limit)
    }
    pub unsafe fn nvmlDeviceGetGpuOperationMode(
        &self,
        device: nvmlDevice_t,
        current: *mut nvmlGpuOperationMode_t,
        pending: *mut nvmlGpuOperationMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuOperationMode
            .as_ref()
            .expect("Expected function, got error."))(device, current, pending)
    }
    pub unsafe fn nvmlDeviceGetMemoryInfo(
        &self,
        device: nvmlDevice_t,
        memory: *mut nvmlMemory_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMemoryInfo
            .as_ref()
            .expect("Expected function, got error."))(device, memory)
    }
    pub unsafe fn nvmlDeviceGetMemoryInfo_v2(
        &self,
        device: nvmlDevice_t,
        memory: *mut nvmlMemory_v2_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMemoryInfo_v2
            .as_ref()
            .expect("Expected function, got error."))(device, memory)
    }
    pub unsafe fn nvmlDeviceGetComputeMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlComputeMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetComputeMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceGetCudaComputeCapability(
        &self,
        device: nvmlDevice_t,
        major: *mut raw::c_int,
        minor: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCudaComputeCapability
            .as_ref()
            .expect("Expected function, got error."))(device, major, minor)
    }
    pub unsafe fn nvmlDeviceGetEccMode(
        &self,
        device: nvmlDevice_t,
        current: *mut nvmlEnableState_t,
        pending: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEccMode
            .as_ref()
            .expect("Expected function, got error."))(device, current, pending)
    }
    pub unsafe fn nvmlDeviceGetDefaultEccMode(
        &self,
        device: nvmlDevice_t,
        defaultMode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDefaultEccMode
            .as_ref()
            .expect("Expected function, got error."))(device, defaultMode)
    }
    pub unsafe fn nvmlDeviceGetBoardId(
        &self,
        device: nvmlDevice_t,
        boardId: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBoardId
            .as_ref()
            .expect("Expected function, got error."))(device, boardId)
    }
    pub unsafe fn nvmlDeviceGetMultiGpuBoard(
        &self,
        device: nvmlDevice_t,
        multiGpuBool: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMultiGpuBoard
            .as_ref()
            .expect("Expected function, got error."))(device, multiGpuBool)
    }
    pub unsafe fn nvmlDeviceGetTotalEccErrors(
        &self,
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        eccCounts: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetTotalEccErrors
            .as_ref()
            .expect("Expected function, got error."))(
            device, errorType, counterType, eccCounts
        )
    }
    pub unsafe fn nvmlDeviceGetDetailedEccErrors(
        &self,
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        eccCounts: *mut nvmlEccErrorCounts_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDetailedEccErrors
            .as_ref()
            .expect("Expected function, got error."))(
            device, errorType, counterType, eccCounts
        )
    }
    pub unsafe fn nvmlDeviceGetMemoryErrorCounter(
        &self,
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        locationType: nvmlMemoryLocation_t,
        count: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMemoryErrorCounter
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            errorType,
            counterType,
            locationType,
            count,
        )
    }
    pub unsafe fn nvmlDeviceGetUtilizationRates(
        &self,
        device: nvmlDevice_t,
        utilization: *mut nvmlUtilization_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetUtilizationRates
            .as_ref()
            .expect("Expected function, got error."))(device, utilization)
    }
    pub unsafe fn nvmlDeviceGetEncoderUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut raw::c_uint,
        samplingPeriodUs: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEncoderUtilization
            .as_ref()
            .expect("Expected function, got error."))(device, utilization, samplingPeriodUs)
    }
    pub unsafe fn nvmlDeviceGetEncoderCapacity(
        &self,
        device: nvmlDevice_t,
        encoderQueryType: nvmlEncoderType_t,
        encoderCapacity: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEncoderCapacity
            .as_ref()
            .expect("Expected function, got error."))(
            device, encoderQueryType, encoderCapacity
        )
    }
    pub unsafe fn nvmlDeviceGetEncoderStats(
        &self,
        device: nvmlDevice_t,
        sessionCount: *mut raw::c_uint,
        averageFps: *mut raw::c_uint,
        averageLatency: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEncoderStats
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            sessionCount,
            averageFps,
            averageLatency,
        )
    }
    pub unsafe fn nvmlDeviceGetEncoderSessions(
        &self,
        device: nvmlDevice_t,
        sessionCount: *mut raw::c_uint,
        sessionInfos: *mut nvmlEncoderSessionInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetEncoderSessions
            .as_ref()
            .expect("Expected function, got error."))(device, sessionCount, sessionInfos)
    }
    pub unsafe fn nvmlDeviceGetDecoderUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut raw::c_uint,
        samplingPeriodUs: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDecoderUtilization
            .as_ref()
            .expect("Expected function, got error."))(device, utilization, samplingPeriodUs)
    }
    pub unsafe fn nvmlDeviceGetJpgUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut raw::c_uint,
        samplingPeriodUs: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetJpgUtilization
            .as_ref()
            .expect("Expected function, got error."))(device, utilization, samplingPeriodUs)
    }
    pub unsafe fn nvmlDeviceGetOfaUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut raw::c_uint,
        samplingPeriodUs: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetOfaUtilization
            .as_ref()
            .expect("Expected function, got error."))(device, utilization, samplingPeriodUs)
    }
    pub unsafe fn nvmlDeviceGetFBCStats(
        &self,
        device: nvmlDevice_t,
        fbcStats: *mut nvmlFBCStats_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFBCStats
            .as_ref()
            .expect("Expected function, got error."))(device, fbcStats)
    }
    pub unsafe fn nvmlDeviceGetFBCSessions(
        &self,
        device: nvmlDevice_t,
        sessionCount: *mut raw::c_uint,
        sessionInfo: *mut nvmlFBCSessionInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFBCSessions
            .as_ref()
            .expect("Expected function, got error."))(device, sessionCount, sessionInfo)
    }
    pub unsafe fn nvmlDeviceGetDriverModel(
        &self,
        device: nvmlDevice_t,
        current: *mut nvmlDriverModel_t,
        pending: *mut nvmlDriverModel_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDriverModel
            .as_ref()
            .expect("Expected function, got error."))(device, current, pending)
    }
    pub unsafe fn nvmlDeviceGetVbiosVersion(
        &self,
        device: nvmlDevice_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVbiosVersion
            .as_ref()
            .expect("Expected function, got error."))(device, version, length)
    }
    pub unsafe fn nvmlDeviceGetBridgeChipInfo(
        &self,
        device: nvmlDevice_t,
        bridgeHierarchy: *mut nvmlBridgeChipHierarchy_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBridgeChipInfo
            .as_ref()
            .expect("Expected function, got error."))(device, bridgeHierarchy)
    }
    pub unsafe fn nvmlDeviceGetComputeRunningProcesses_v3(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetComputeRunningProcesses_v3
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    pub unsafe fn nvmlDeviceGetGraphicsRunningProcesses_v3(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGraphicsRunningProcesses_v3
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    pub unsafe fn nvmlDeviceGetMPSComputeRunningProcesses_v3(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMPSComputeRunningProcesses_v3
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    pub unsafe fn nvmlDeviceGetRunningProcessDetailList(
        &self,
        device: nvmlDevice_t,
        plist: *mut nvmlProcessDetailList_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetRunningProcessDetailList
            .as_ref()
            .expect("Expected function, got error."))(device, plist)
    }
    pub unsafe fn nvmlDeviceOnSameBoard(
        &self,
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        onSameBoard: *mut raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceOnSameBoard
            .as_ref()
            .expect("Expected function, got error."))(device1, device2, onSameBoard)
    }
    pub unsafe fn nvmlDeviceGetAPIRestriction(
        &self,
        device: nvmlDevice_t,
        apiType: nvmlRestrictedAPI_t,
        isRestricted: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAPIRestriction
            .as_ref()
            .expect("Expected function, got error."))(device, apiType, isRestricted)
    }
    pub unsafe fn nvmlDeviceGetSamples(
        &self,
        device: nvmlDevice_t,
        type_: nvmlSamplingType_t,
        lastSeenTimeStamp: raw::c_ulonglong,
        sampleValType: *mut nvmlValueType_t,
        sampleCount: *mut raw::c_uint,
        samples: *mut nvmlSample_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSamples
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            type_,
            lastSeenTimeStamp,
            sampleValType,
            sampleCount,
            samples,
        )
    }
    pub unsafe fn nvmlDeviceGetBAR1MemoryInfo(
        &self,
        device: nvmlDevice_t,
        bar1Memory: *mut nvmlBAR1Memory_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBAR1MemoryInfo
            .as_ref()
            .expect("Expected function, got error."))(device, bar1Memory)
    }
    pub unsafe fn nvmlDeviceGetViolationStatus(
        &self,
        device: nvmlDevice_t,
        perfPolicyType: nvmlPerfPolicyType_t,
        violTime: *mut nvmlViolationTime_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetViolationStatus
            .as_ref()
            .expect("Expected function, got error."))(device, perfPolicyType, violTime)
    }
    pub unsafe fn nvmlDeviceGetIrqNum(
        &self,
        device: nvmlDevice_t,
        irqNum: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetIrqNum
            .as_ref()
            .expect("Expected function, got error."))(device, irqNum)
    }
    pub unsafe fn nvmlDeviceGetNumGpuCores(
        &self,
        device: nvmlDevice_t,
        numCores: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNumGpuCores
            .as_ref()
            .expect("Expected function, got error."))(device, numCores)
    }
    pub unsafe fn nvmlDeviceGetPowerSource(
        &self,
        device: nvmlDevice_t,
        powerSource: *mut nvmlPowerSource_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPowerSource
            .as_ref()
            .expect("Expected function, got error."))(device, powerSource)
    }
    pub unsafe fn nvmlDeviceGetMemoryBusWidth(
        &self,
        device: nvmlDevice_t,
        busWidth: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMemoryBusWidth
            .as_ref()
            .expect("Expected function, got error."))(device, busWidth)
    }
    pub unsafe fn nvmlDeviceGetPcieLinkMaxSpeed(
        &self,
        device: nvmlDevice_t,
        maxSpeed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPcieLinkMaxSpeed
            .as_ref()
            .expect("Expected function, got error."))(device, maxSpeed)
    }
    pub unsafe fn nvmlDeviceGetPcieSpeed(
        &self,
        device: nvmlDevice_t,
        pcieSpeed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPcieSpeed
            .as_ref()
            .expect("Expected function, got error."))(device, pcieSpeed)
    }
    pub unsafe fn nvmlDeviceGetAdaptiveClockInfoStatus(
        &self,
        device: nvmlDevice_t,
        adaptiveClockStatus: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAdaptiveClockInfoStatus
            .as_ref()
            .expect("Expected function, got error."))(device, adaptiveClockStatus)
    }
    pub unsafe fn nvmlDeviceGetBusType(
        &self,
        device: nvmlDevice_t,
        type_: *mut nvmlBusType_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetBusType
            .as_ref()
            .expect("Expected function, got error."))(device, type_)
    }
    pub unsafe fn nvmlDeviceGetGpuFabricInfo(
        &self,
        device: nvmlDevice_t,
        gpuFabricInfo: *mut nvmlGpuFabricInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuFabricInfo
            .as_ref()
            .expect("Expected function, got error."))(device, gpuFabricInfo)
    }
    pub unsafe fn nvmlSystemGetConfComputeCapabilities(
        &self,
        capabilities: *mut nvmlConfComputeSystemCaps_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetConfComputeCapabilities
            .as_ref()
            .expect("Expected function, got error."))(capabilities)
    }
    pub unsafe fn nvmlSystemGetConfComputeState(
        &self,
        state: *mut nvmlConfComputeSystemState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetConfComputeState
            .as_ref()
            .expect("Expected function, got error."))(state)
    }
    pub unsafe fn nvmlDeviceGetConfComputeMemSizeInfo(
        &self,
        device: nvmlDevice_t,
        memInfo: *mut nvmlConfComputeMemSizeInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetConfComputeMemSizeInfo
            .as_ref()
            .expect("Expected function, got error."))(device, memInfo)
    }
    pub unsafe fn nvmlSystemGetConfComputeGpusReadyState(
        &self,
        isAcceptingWork: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemGetConfComputeGpusReadyState
            .as_ref()
            .expect("Expected function, got error."))(isAcceptingWork)
    }
    pub unsafe fn nvmlDeviceGetConfComputeProtectedMemoryUsage(
        &self,
        device: nvmlDevice_t,
        memory: *mut nvmlMemory_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetConfComputeProtectedMemoryUsage
            .as_ref()
            .expect("Expected function, got error."))(device, memory)
    }
    pub unsafe fn nvmlDeviceGetConfComputeGpuCertificate(
        &self,
        device: nvmlDevice_t,
        gpuCert: *mut nvmlConfComputeGpuCertificate_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetConfComputeGpuCertificate
            .as_ref()
            .expect("Expected function, got error."))(device, gpuCert)
    }
    pub unsafe fn nvmlDeviceGetConfComputeGpuAttestationReport(
        &self,
        device: nvmlDevice_t,
        gpuAtstReport: *mut nvmlConfComputeGpuAttestationReport_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetConfComputeGpuAttestationReport
            .as_ref()
            .expect("Expected function, got error."))(device, gpuAtstReport)
    }
    pub unsafe fn nvmlDeviceGetAccountingMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAccountingMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceGetAccountingStats(
        &self,
        device: nvmlDevice_t,
        pid: raw::c_uint,
        stats: *mut nvmlAccountingStats_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAccountingStats
            .as_ref()
            .expect("Expected function, got error."))(device, pid, stats)
    }
    pub unsafe fn nvmlDeviceGetAccountingPids(
        &self,
        device: nvmlDevice_t,
        count: *mut raw::c_uint,
        pids: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAccountingPids
            .as_ref()
            .expect("Expected function, got error."))(device, count, pids)
    }
    pub unsafe fn nvmlDeviceGetAccountingBufferSize(
        &self,
        device: nvmlDevice_t,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAccountingBufferSize
            .as_ref()
            .expect("Expected function, got error."))(device, bufferSize)
    }
    pub unsafe fn nvmlDeviceGetRetiredPages(
        &self,
        device: nvmlDevice_t,
        cause: nvmlPageRetirementCause_t,
        pageCount: *mut raw::c_uint,
        addresses: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetRetiredPages
            .as_ref()
            .expect("Expected function, got error."))(device, cause, pageCount, addresses)
    }
    pub unsafe fn nvmlDeviceGetRetiredPages_v2(
        &self,
        device: nvmlDevice_t,
        cause: nvmlPageRetirementCause_t,
        pageCount: *mut raw::c_uint,
        addresses: *mut raw::c_ulonglong,
        timestamps: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetRetiredPages_v2
            .as_ref()
            .expect("Expected function, got error."))(
            device, cause, pageCount, addresses, timestamps,
        )
    }
    pub unsafe fn nvmlDeviceGetRetiredPagesPendingStatus(
        &self,
        device: nvmlDevice_t,
        isPending: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetRetiredPagesPendingStatus
            .as_ref()
            .expect("Expected function, got error."))(device, isPending)
    }
    pub unsafe fn nvmlDeviceGetRemappedRows(
        &self,
        device: nvmlDevice_t,
        corrRows: *mut raw::c_uint,
        uncRows: *mut raw::c_uint,
        isPending: *mut raw::c_uint,
        failureOccurred: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetRemappedRows
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            corrRows,
            uncRows,
            isPending,
            failureOccurred,
        )
    }
    pub unsafe fn nvmlDeviceGetRowRemapperHistogram(
        &self,
        device: nvmlDevice_t,
        values: *mut nvmlRowRemapperHistogramValues_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetRowRemapperHistogram
            .as_ref()
            .expect("Expected function, got error."))(device, values)
    }
    pub unsafe fn nvmlDeviceGetArchitecture(
        &self,
        device: nvmlDevice_t,
        arch: *mut nvmlDeviceArchitecture_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetArchitecture
            .as_ref()
            .expect("Expected function, got error."))(device, arch)
    }
    pub unsafe fn nvmlUnitSetLedState(
        &self,
        unit: nvmlUnit_t,
        color: nvmlLedColor_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlUnitSetLedState
            .as_ref()
            .expect("Expected function, got error."))(unit, color)
    }
    pub unsafe fn nvmlDeviceSetPersistenceMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetPersistenceMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceSetComputeMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlComputeMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetComputeMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceSetEccMode(
        &self,
        device: nvmlDevice_t,
        ecc: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetEccMode
            .as_ref()
            .expect("Expected function, got error."))(device, ecc)
    }
    pub unsafe fn nvmlDeviceClearEccErrorCounts(
        &self,
        device: nvmlDevice_t,
        counterType: nvmlEccCounterType_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceClearEccErrorCounts
            .as_ref()
            .expect("Expected function, got error."))(device, counterType)
    }
    pub unsafe fn nvmlDeviceSetDriverModel(
        &self,
        device: nvmlDevice_t,
        driverModel: nvmlDriverModel_t,
        flags: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetDriverModel
            .as_ref()
            .expect("Expected function, got error."))(device, driverModel, flags)
    }
    pub unsafe fn nvmlDeviceSetGpuLockedClocks(
        &self,
        device: nvmlDevice_t,
        minGpuClockMHz: raw::c_uint,
        maxGpuClockMHz: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetGpuLockedClocks
            .as_ref()
            .expect("Expected function, got error."))(device, minGpuClockMHz, maxGpuClockMHz)
    }
    pub unsafe fn nvmlDeviceResetGpuLockedClocks(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceResetGpuLockedClocks
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceSetMemoryLockedClocks(
        &self,
        device: nvmlDevice_t,
        minMemClockMHz: raw::c_uint,
        maxMemClockMHz: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetMemoryLockedClocks
            .as_ref()
            .expect("Expected function, got error."))(device, minMemClockMHz, maxMemClockMHz)
    }
    pub unsafe fn nvmlDeviceResetMemoryLockedClocks(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceResetMemoryLockedClocks
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceSetApplicationsClocks(
        &self,
        device: nvmlDevice_t,
        memClockMHz: raw::c_uint,
        graphicsClockMHz: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetApplicationsClocks
            .as_ref()
            .expect("Expected function, got error."))(device, memClockMHz, graphicsClockMHz)
    }
    pub unsafe fn nvmlDeviceGetClkMonStatus(
        &self,
        device: nvmlDevice_t,
        status: *mut nvmlClkMonStatus_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetClkMonStatus
            .as_ref()
            .expect("Expected function, got error."))(device, status)
    }
    pub unsafe fn nvmlDeviceSetPowerManagementLimit(
        &self,
        device: nvmlDevice_t,
        limit: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetPowerManagementLimit
            .as_ref()
            .expect("Expected function, got error."))(device, limit)
    }
    pub unsafe fn nvmlDeviceSetGpuOperationMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlGpuOperationMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetGpuOperationMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceSetAPIRestriction(
        &self,
        device: nvmlDevice_t,
        apiType: nvmlRestrictedAPI_t,
        isRestricted: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetAPIRestriction
            .as_ref()
            .expect("Expected function, got error."))(device, apiType, isRestricted)
    }
    pub unsafe fn nvmlDeviceSetFanSpeed_v2(
        &self,
        device: nvmlDevice_t,
        fan: raw::c_uint,
        speed: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetFanSpeed_v2
            .as_ref()
            .expect("Expected function, got error."))(device, fan, speed)
    }
    pub unsafe fn nvmlDeviceSetGpcClkVfOffset(
        &self,
        device: nvmlDevice_t,
        offset: raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetGpcClkVfOffset
            .as_ref()
            .expect("Expected function, got error."))(device, offset)
    }
    pub unsafe fn nvmlDeviceSetMemClkVfOffset(
        &self,
        device: nvmlDevice_t,
        offset: raw::c_int,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetMemClkVfOffset
            .as_ref()
            .expect("Expected function, got error."))(device, offset)
    }
    pub unsafe fn nvmlDeviceSetConfComputeUnprotectedMemSize(
        &self,
        device: nvmlDevice_t,
        sizeKiB: raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetConfComputeUnprotectedMemSize
            .as_ref()
            .expect("Expected function, got error."))(device, sizeKiB)
    }
    pub unsafe fn nvmlSystemSetConfComputeGpusReadyState(
        &self,
        isAcceptingWork: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlSystemSetConfComputeGpusReadyState
            .as_ref()
            .expect("Expected function, got error."))(isAcceptingWork)
    }
    pub unsafe fn nvmlDeviceSetAccountingMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetAccountingMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode)
    }
    pub unsafe fn nvmlDeviceClearAccountingPids(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceClearAccountingPids
            .as_ref()
            .expect("Expected function, got error."))(device)
    }
    pub unsafe fn nvmlDeviceGetNvLinkState(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        isActive: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkState
            .as_ref()
            .expect("Expected function, got error."))(device, link, isActive)
    }
    pub unsafe fn nvmlDeviceGetNvLinkVersion(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        version: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkVersion
            .as_ref()
            .expect("Expected function, got error."))(device, link, version)
    }
    pub unsafe fn nvmlDeviceGetNvLinkCapability(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        capability: nvmlNvLinkCapability_t,
        capResult: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkCapability
            .as_ref()
            .expect("Expected function, got error."))(device, link, capability, capResult)
    }
    pub unsafe fn nvmlDeviceGetNvLinkRemotePciInfo_v2(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkRemotePciInfo_v2
            .as_ref()
            .expect("Expected function, got error."))(device, link, pci)
    }
    pub unsafe fn nvmlDeviceGetNvLinkErrorCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: nvmlNvLinkErrorCounter_t,
        counterValue: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkErrorCounter
            .as_ref()
            .expect("Expected function, got error."))(device, link, counter, counterValue)
    }
    pub unsafe fn nvmlDeviceResetNvLinkErrorCounters(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceResetNvLinkErrorCounters
            .as_ref()
            .expect("Expected function, got error."))(device, link)
    }
    pub unsafe fn nvmlDeviceSetNvLinkUtilizationControl(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        control: *mut nvmlNvLinkUtilizationControl_t,
        reset: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetNvLinkUtilizationControl
            .as_ref()
            .expect("Expected function, got error."))(device, link, counter, control, reset)
    }
    pub unsafe fn nvmlDeviceGetNvLinkUtilizationControl(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        control: *mut nvmlNvLinkUtilizationControl_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkUtilizationControl
            .as_ref()
            .expect("Expected function, got error."))(device, link, counter, control)
    }
    pub unsafe fn nvmlDeviceGetNvLinkUtilizationCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        rxcounter: *mut raw::c_ulonglong,
        txcounter: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkUtilizationCounter
            .as_ref()
            .expect("Expected function, got error."))(
            device, link, counter, rxcounter, txcounter
        )
    }
    pub unsafe fn nvmlDeviceFreezeNvLinkUtilizationCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        freeze: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceFreezeNvLinkUtilizationCounter
            .as_ref()
            .expect("Expected function, got error."))(device, link, counter, freeze)
    }
    pub unsafe fn nvmlDeviceResetNvLinkUtilizationCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceResetNvLinkUtilizationCounter
            .as_ref()
            .expect("Expected function, got error."))(device, link, counter)
    }
    pub unsafe fn nvmlDeviceGetNvLinkRemoteDeviceType(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        pNvLinkDeviceType: *mut nvmlIntNvLinkDeviceType_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkRemoteDeviceType
            .as_ref()
            .expect("Expected function, got error."))(device, link, pNvLinkDeviceType)
    }
    pub unsafe fn nvmlEventSetCreate(&self, set: *mut nvmlEventSet_t) -> nvmlReturn_t {
        (self
            .nvmlEventSetCreate
            .as_ref()
            .expect("Expected function, got error."))(set)
    }
    pub unsafe fn nvmlDeviceRegisterEvents(
        &self,
        device: nvmlDevice_t,
        eventTypes: raw::c_ulonglong,
        set: nvmlEventSet_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceRegisterEvents
            .as_ref()
            .expect("Expected function, got error."))(device, eventTypes, set)
    }
    pub unsafe fn nvmlDeviceGetSupportedEventTypes(
        &self,
        device: nvmlDevice_t,
        eventTypes: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedEventTypes
            .as_ref()
            .expect("Expected function, got error."))(device, eventTypes)
    }
    pub unsafe fn nvmlEventSetWait_v2(
        &self,
        set: nvmlEventSet_t,
        data: *mut nvmlEventData_t,
        timeoutms: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlEventSetWait_v2
            .as_ref()
            .expect("Expected function, got error."))(set, data, timeoutms)
    }
    pub unsafe fn nvmlEventSetFree(&self, set: nvmlEventSet_t) -> nvmlReturn_t {
        (self
            .nvmlEventSetFree
            .as_ref()
            .expect("Expected function, got error."))(set)
    }
    pub unsafe fn nvmlDeviceModifyDrainState(
        &self,
        pciInfo: *mut nvmlPciInfo_t,
        newState: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceModifyDrainState
            .as_ref()
            .expect("Expected function, got error."))(pciInfo, newState)
    }
    pub unsafe fn nvmlDeviceQueryDrainState(
        &self,
        pciInfo: *mut nvmlPciInfo_t,
        currentState: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceQueryDrainState
            .as_ref()
            .expect("Expected function, got error."))(pciInfo, currentState)
    }
    pub unsafe fn nvmlDeviceRemoveGpu_v2(
        &self,
        pciInfo: *mut nvmlPciInfo_t,
        gpuState: nvmlDetachGpuState_t,
        linkState: nvmlPcieLinkState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceRemoveGpu_v2
            .as_ref()
            .expect("Expected function, got error."))(pciInfo, gpuState, linkState)
    }
    pub unsafe fn nvmlDeviceDiscoverGpus(&self, pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceDiscoverGpus
            .as_ref()
            .expect("Expected function, got error."))(pciInfo)
    }
    pub unsafe fn nvmlDeviceGetFieldValues(
        &self,
        device: nvmlDevice_t,
        valuesCount: raw::c_int,
        values: *mut nvmlFieldValue_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetFieldValues
            .as_ref()
            .expect("Expected function, got error."))(device, valuesCount, values)
    }
    pub unsafe fn nvmlDeviceClearFieldValues(
        &self,
        device: nvmlDevice_t,
        valuesCount: raw::c_int,
        values: *mut nvmlFieldValue_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceClearFieldValues
            .as_ref()
            .expect("Expected function, got error."))(device, valuesCount, values)
    }
    pub unsafe fn nvmlDeviceGetVirtualizationMode(
        &self,
        device: nvmlDevice_t,
        pVirtualMode: *mut nvmlGpuVirtualizationMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVirtualizationMode
            .as_ref()
            .expect("Expected function, got error."))(device, pVirtualMode)
    }
    pub unsafe fn nvmlDeviceGetHostVgpuMode(
        &self,
        device: nvmlDevice_t,
        pHostVgpuMode: *mut nvmlHostVgpuMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHostVgpuMode
            .as_ref()
            .expect("Expected function, got error."))(device, pHostVgpuMode)
    }
    pub unsafe fn nvmlDeviceSetVirtualizationMode(
        &self,
        device: nvmlDevice_t,
        virtualMode: nvmlGpuVirtualizationMode_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetVirtualizationMode
            .as_ref()
            .expect("Expected function, got error."))(device, virtualMode)
    }
    pub unsafe fn nvmlDeviceGetGridLicensableFeatures_v4(
        &self,
        device: nvmlDevice_t,
        pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGridLicensableFeatures_v4
            .as_ref()
            .expect("Expected function, got error."))(device, pGridLicensableFeatures)
    }
    pub unsafe fn nvmlDeviceGetProcessUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut nvmlProcessUtilizationSample_t,
        processSamplesCount: *mut raw::c_uint,
        lastSeenTimeStamp: raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetProcessUtilization
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            utilization,
            processSamplesCount,
            lastSeenTimeStamp,
        )
    }
    pub unsafe fn nvmlDeviceGetGspFirmwareVersion(
        &self,
        device: nvmlDevice_t,
        version: *mut raw::c_char,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGspFirmwareVersion
            .as_ref()
            .expect("Expected function, got error."))(device, version)
    }
    pub unsafe fn nvmlDeviceGetGspFirmwareMode(
        &self,
        device: nvmlDevice_t,
        isEnabled: *mut raw::c_uint,
        defaultMode: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGspFirmwareMode
            .as_ref()
            .expect("Expected function, got error."))(device, isEnabled, defaultMode)
    }
    pub unsafe fn nvmlGetVgpuDriverCapabilities(
        &self,
        capability: nvmlVgpuDriverCapability_t,
        capResult: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlGetVgpuDriverCapabilities
            .as_ref()
            .expect("Expected function, got error."))(capability, capResult)
    }
    pub unsafe fn nvmlDeviceGetVgpuCapabilities(
        &self,
        device: nvmlDevice_t,
        capability: nvmlDeviceVgpuCapability_t,
        capResult: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVgpuCapabilities
            .as_ref()
            .expect("Expected function, got error."))(device, capability, capResult)
    }
    pub unsafe fn nvmlDeviceGetSupportedVgpus(
        &self,
        device: nvmlDevice_t,
        vgpuCount: *mut raw::c_uint,
        vgpuTypeIds: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetSupportedVgpus
            .as_ref()
            .expect("Expected function, got error."))(device, vgpuCount, vgpuTypeIds)
    }
    pub unsafe fn nvmlDeviceGetCreatableVgpus(
        &self,
        device: nvmlDevice_t,
        vgpuCount: *mut raw::c_uint,
        vgpuTypeIds: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCreatableVgpus
            .as_ref()
            .expect("Expected function, got error."))(device, vgpuCount, vgpuTypeIds)
    }
    pub unsafe fn nvmlVgpuTypeGetClass(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeClass: *mut raw::c_char,
        size: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetClass
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, vgpuTypeClass, size)
    }
    pub unsafe fn nvmlVgpuTypeGetName(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeName: *mut raw::c_char,
        size: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetName
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, vgpuTypeName, size)
    }
    pub unsafe fn nvmlVgpuTypeGetGpuInstanceProfileId(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        gpuInstanceProfileId: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetGpuInstanceProfileId
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, gpuInstanceProfileId)
    }
    pub unsafe fn nvmlVgpuTypeGetDeviceID(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        deviceID: *mut raw::c_ulonglong,
        subsystemID: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetDeviceID
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, deviceID, subsystemID)
    }
    pub unsafe fn nvmlVgpuTypeGetFramebufferSize(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        fbSize: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetFramebufferSize
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, fbSize)
    }
    pub unsafe fn nvmlVgpuTypeGetNumDisplayHeads(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        numDisplayHeads: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetNumDisplayHeads
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, numDisplayHeads)
    }
    pub unsafe fn nvmlVgpuTypeGetResolution(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        displayIndex: raw::c_uint,
        xdim: *mut raw::c_uint,
        ydim: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetResolution
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, displayIndex, xdim, ydim)
    }
    pub unsafe fn nvmlVgpuTypeGetLicense(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeLicenseString: *mut raw::c_char,
        size: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetLicense
            .as_ref()
            .expect("Expected function, got error."))(
            vgpuTypeId, vgpuTypeLicenseString, size
        )
    }
    pub unsafe fn nvmlVgpuTypeGetFrameRateLimit(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        frameRateLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetFrameRateLimit
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, frameRateLimit)
    }
    pub unsafe fn nvmlVgpuTypeGetMaxInstances(
        &self,
        device: nvmlDevice_t,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuInstanceCount: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetMaxInstances
            .as_ref()
            .expect("Expected function, got error."))(device, vgpuTypeId, vgpuInstanceCount)
    }
    pub unsafe fn nvmlVgpuTypeGetMaxInstancesPerVm(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuInstanceCountPerVm: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetMaxInstancesPerVm
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, vgpuInstanceCountPerVm)
    }
    pub unsafe fn nvmlDeviceGetActiveVgpus(
        &self,
        device: nvmlDevice_t,
        vgpuCount: *mut raw::c_uint,
        vgpuInstances: *mut nvmlVgpuInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetActiveVgpus
            .as_ref()
            .expect("Expected function, got error."))(device, vgpuCount, vgpuInstances)
    }
    pub unsafe fn nvmlVgpuInstanceGetVmID(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        vmId: *mut raw::c_char,
        size: raw::c_uint,
        vmIdType: *mut nvmlVgpuVmIdType_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetVmID
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, vmId, size, vmIdType)
    }
    pub unsafe fn nvmlVgpuInstanceGetUUID(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        uuid: *mut raw::c_char,
        size: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetUUID
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, uuid, size)
    }
    pub unsafe fn nvmlVgpuInstanceGetVmDriverVersion(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetVmDriverVersion
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, version, length)
    }
    pub unsafe fn nvmlVgpuInstanceGetFbUsage(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        fbUsage: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetFbUsage
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, fbUsage)
    }
    pub unsafe fn nvmlVgpuInstanceGetLicenseStatus(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        licensed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetLicenseStatus
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, licensed)
    }
    pub unsafe fn nvmlVgpuInstanceGetType(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuTypeId: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetType
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, vgpuTypeId)
    }
    pub unsafe fn nvmlVgpuInstanceGetFrameRateLimit(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        frameRateLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetFrameRateLimit
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, frameRateLimit)
    }
    pub unsafe fn nvmlVgpuInstanceGetEccMode(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        eccMode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetEccMode
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, eccMode)
    }
    pub unsafe fn nvmlVgpuInstanceGetEncoderCapacity(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        encoderCapacity: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetEncoderCapacity
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, encoderCapacity)
    }
    pub unsafe fn nvmlVgpuInstanceSetEncoderCapacity(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        encoderCapacity: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceSetEncoderCapacity
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, encoderCapacity)
    }
    pub unsafe fn nvmlVgpuInstanceGetEncoderStats(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut raw::c_uint,
        averageFps: *mut raw::c_uint,
        averageLatency: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetEncoderStats
            .as_ref()
            .expect("Expected function, got error."))(
            vgpuInstance,
            sessionCount,
            averageFps,
            averageLatency,
        )
    }
    pub unsafe fn nvmlVgpuInstanceGetEncoderSessions(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut raw::c_uint,
        sessionInfo: *mut nvmlEncoderSessionInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetEncoderSessions
            .as_ref()
            .expect("Expected function, got error."))(
            vgpuInstance, sessionCount, sessionInfo
        )
    }
    pub unsafe fn nvmlVgpuInstanceGetFBCStats(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        fbcStats: *mut nvmlFBCStats_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetFBCStats
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, fbcStats)
    }
    pub unsafe fn nvmlVgpuInstanceGetFBCSessions(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut raw::c_uint,
        sessionInfo: *mut nvmlFBCSessionInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetFBCSessions
            .as_ref()
            .expect("Expected function, got error."))(
            vgpuInstance, sessionCount, sessionInfo
        )
    }
    pub unsafe fn nvmlVgpuInstanceGetGpuInstanceId(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        gpuInstanceId: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetGpuInstanceId
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, gpuInstanceId)
    }
    pub unsafe fn nvmlVgpuInstanceGetGpuPciId(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuPciId: *mut raw::c_char,
        length: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetGpuPciId
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, vgpuPciId, length)
    }
    pub unsafe fn nvmlVgpuTypeGetCapabilities(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        capability: nvmlVgpuCapability_t,
        capResult: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuTypeGetCapabilities
            .as_ref()
            .expect("Expected function, got error."))(vgpuTypeId, capability, capResult)
    }
    pub unsafe fn nvmlVgpuInstanceGetMetadata(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuMetadata: *mut nvmlVgpuMetadata_t,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetMetadata
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, vgpuMetadata, bufferSize)
    }
    pub unsafe fn nvmlDeviceGetVgpuMetadata(
        &self,
        device: nvmlDevice_t,
        pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVgpuMetadata
            .as_ref()
            .expect("Expected function, got error."))(device, pgpuMetadata, bufferSize)
    }
    pub unsafe fn nvmlGetVgpuCompatibility(
        &self,
        vgpuMetadata: *mut nvmlVgpuMetadata_t,
        pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
        compatibilityInfo: *mut nvmlVgpuPgpuCompatibility_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGetVgpuCompatibility
            .as_ref()
            .expect("Expected function, got error."))(
            vgpuMetadata, pgpuMetadata, compatibilityInfo
        )
    }
    pub unsafe fn nvmlDeviceGetPgpuMetadataString(
        &self,
        device: nvmlDevice_t,
        pgpuMetadata: *mut raw::c_char,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPgpuMetadataString
            .as_ref()
            .expect("Expected function, got error."))(device, pgpuMetadata, bufferSize)
    }
    pub unsafe fn nvmlDeviceGetVgpuSchedulerLog(
        &self,
        device: nvmlDevice_t,
        pSchedulerLog: *mut nvmlVgpuSchedulerLog_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVgpuSchedulerLog
            .as_ref()
            .expect("Expected function, got error."))(device, pSchedulerLog)
    }
    pub unsafe fn nvmlDeviceGetVgpuSchedulerState(
        &self,
        device: nvmlDevice_t,
        pSchedulerState: *mut nvmlVgpuSchedulerGetState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVgpuSchedulerState
            .as_ref()
            .expect("Expected function, got error."))(device, pSchedulerState)
    }
    pub unsafe fn nvmlDeviceGetVgpuSchedulerCapabilities(
        &self,
        device: nvmlDevice_t,
        pCapabilities: *mut nvmlVgpuSchedulerCapabilities_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVgpuSchedulerCapabilities
            .as_ref()
            .expect("Expected function, got error."))(device, pCapabilities)
    }
    pub unsafe fn nvmlDeviceSetVgpuSchedulerState(
        &self,
        device: nvmlDevice_t,
        pSchedulerState: *mut nvmlVgpuSchedulerSetState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetVgpuSchedulerState
            .as_ref()
            .expect("Expected function, got error."))(device, pSchedulerState)
    }
    pub unsafe fn nvmlGetVgpuVersion(
        &self,
        supported: *mut nvmlVgpuVersion_t,
        current: *mut nvmlVgpuVersion_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGetVgpuVersion
            .as_ref()
            .expect("Expected function, got error."))(supported, current)
    }
    pub unsafe fn nvmlSetVgpuVersion(&self, vgpuVersion: *mut nvmlVgpuVersion_t) -> nvmlReturn_t {
        (self
            .nvmlSetVgpuVersion
            .as_ref()
            .expect("Expected function, got error."))(vgpuVersion)
    }
    pub unsafe fn nvmlDeviceGetVgpuUtilization(
        &self,
        device: nvmlDevice_t,
        lastSeenTimeStamp: raw::c_ulonglong,
        sampleValType: *mut nvmlValueType_t,
        vgpuInstanceSamplesCount: *mut raw::c_uint,
        utilizationSamples: *mut nvmlVgpuInstanceUtilizationSample_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVgpuUtilization
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            lastSeenTimeStamp,
            sampleValType,
            vgpuInstanceSamplesCount,
            utilizationSamples,
        )
    }
    pub unsafe fn nvmlDeviceGetVgpuProcessUtilization(
        &self,
        device: nvmlDevice_t,
        lastSeenTimeStamp: raw::c_ulonglong,
        vgpuProcessSamplesCount: *mut raw::c_uint,
        utilizationSamples: *mut nvmlVgpuProcessUtilizationSample_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetVgpuProcessUtilization
            .as_ref()
            .expect("Expected function, got error."))(
            device,
            lastSeenTimeStamp,
            vgpuProcessSamplesCount,
            utilizationSamples,
        )
    }
    pub unsafe fn nvmlVgpuInstanceGetAccountingMode(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetAccountingMode
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, mode)
    }
    pub unsafe fn nvmlVgpuInstanceGetAccountingPids(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        count: *mut raw::c_uint,
        pids: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetAccountingPids
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, count, pids)
    }
    pub unsafe fn nvmlVgpuInstanceGetAccountingStats(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        pid: raw::c_uint,
        stats: *mut nvmlAccountingStats_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetAccountingStats
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, pid, stats)
    }
    pub unsafe fn nvmlVgpuInstanceClearAccountingPids(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceClearAccountingPids
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance)
    }
    pub unsafe fn nvmlVgpuInstanceGetLicenseInfo_v2(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        licenseInfo: *mut nvmlVgpuLicenseInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetLicenseInfo_v2
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, licenseInfo)
    }
    pub unsafe fn nvmlGetExcludedDeviceCount(&self, deviceCount: *mut raw::c_uint) -> nvmlReturn_t {
        (self
            .nvmlGetExcludedDeviceCount
            .as_ref()
            .expect("Expected function, got error."))(deviceCount)
    }
    pub unsafe fn nvmlGetExcludedDeviceInfoByIndex(
        &self,
        index: raw::c_uint,
        info: *mut nvmlExcludedDeviceInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGetExcludedDeviceInfoByIndex
            .as_ref()
            .expect("Expected function, got error."))(index, info)
    }
    pub unsafe fn nvmlDeviceSetMigMode(
        &self,
        device: nvmlDevice_t,
        mode: raw::c_uint,
        activationStatus: *mut nvmlReturn_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetMigMode
            .as_ref()
            .expect("Expected function, got error."))(device, mode, activationStatus)
    }
    pub unsafe fn nvmlDeviceGetMigMode(
        &self,
        device: nvmlDevice_t,
        currentMode: *mut raw::c_uint,
        pendingMode: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMigMode
            .as_ref()
            .expect("Expected function, got error."))(device, currentMode, pendingMode)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceProfileInfo(
        &self,
        device: nvmlDevice_t,
        profile: raw::c_uint,
        info: *mut nvmlGpuInstanceProfileInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstanceProfileInfo
            .as_ref()
            .expect("Expected function, got error."))(device, profile, info)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceProfileInfoV(
        &self,
        device: nvmlDevice_t,
        profile: raw::c_uint,
        info: *mut nvmlGpuInstanceProfileInfo_v2_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstanceProfileInfoV
            .as_ref()
            .expect("Expected function, got error."))(device, profile, info)
    }
    pub unsafe fn nvmlDeviceGetGpuInstancePossiblePlacements_v2(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        placements: *mut nvmlGpuInstancePlacement_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstancePossiblePlacements_v2
            .as_ref()
            .expect("Expected function, got error."))(device, profileId, placements, count)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceRemainingCapacity(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstanceRemainingCapacity
            .as_ref()
            .expect("Expected function, got error."))(device, profileId, count)
    }
    pub unsafe fn nvmlDeviceCreateGpuInstance(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        gpuInstance: *mut nvmlGpuInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceCreateGpuInstance
            .as_ref()
            .expect("Expected function, got error."))(device, profileId, gpuInstance)
    }
    pub unsafe fn nvmlDeviceCreateGpuInstanceWithPlacement(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        placement: *const nvmlGpuInstancePlacement_t,
        gpuInstance: *mut nvmlGpuInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceCreateGpuInstanceWithPlacement
            .as_ref()
            .expect("Expected function, got error."))(
            device, profileId, placement, gpuInstance
        )
    }
    pub unsafe fn nvmlGpuInstanceDestroy(&self, gpuInstance: nvmlGpuInstance_t) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceDestroy
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance)
    }
    pub unsafe fn nvmlDeviceGetGpuInstances(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        gpuInstances: *mut nvmlGpuInstance_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstances
            .as_ref()
            .expect("Expected function, got error."))(device, profileId, gpuInstances, count)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceById(
        &self,
        device: nvmlDevice_t,
        id: raw::c_uint,
        gpuInstance: *mut nvmlGpuInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstanceById
            .as_ref()
            .expect("Expected function, got error."))(device, id, gpuInstance)
    }
    pub unsafe fn nvmlGpuInstanceGetInfo(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        info: *mut nvmlGpuInstanceInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetInfo
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance, info)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstanceProfileInfo(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profile: raw::c_uint,
        engProfile: raw::c_uint,
        info: *mut nvmlComputeInstanceProfileInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetComputeInstanceProfileInfo
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance, profile, engProfile, info)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstanceProfileInfoV(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profile: raw::c_uint,
        engProfile: raw::c_uint,
        info: *mut nvmlComputeInstanceProfileInfo_v2_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetComputeInstanceProfileInfoV
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance, profile, engProfile, info)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstanceRemainingCapacity(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetComputeInstanceRemainingCapacity
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance, profileId, count)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstancePossiblePlacements(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        placements: *mut nvmlComputeInstancePlacement_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetComputeInstancePossiblePlacements
            .as_ref()
            .expect("Expected function, got error."))(
            gpuInstance, profileId, placements, count
        )
    }
    pub unsafe fn nvmlGpuInstanceCreateComputeInstance(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        computeInstance: *mut nvmlComputeInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceCreateComputeInstance
            .as_ref()
            .expect("Expected function, got error."))(
            gpuInstance, profileId, computeInstance
        )
    }
    pub unsafe fn nvmlGpuInstanceCreateComputeInstanceWithPlacement(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        placement: *const nvmlComputeInstancePlacement_t,
        computeInstance: *mut nvmlComputeInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceCreateComputeInstanceWithPlacement
            .as_ref()
            .expect("Expected function, got error."))(
            gpuInstance,
            profileId,
            placement,
            computeInstance,
        )
    }
    pub unsafe fn nvmlComputeInstanceDestroy(
        &self,
        computeInstance: nvmlComputeInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlComputeInstanceDestroy
            .as_ref()
            .expect("Expected function, got error."))(computeInstance)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstances(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        computeInstances: *mut nvmlComputeInstance_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetComputeInstances
            .as_ref()
            .expect("Expected function, got error."))(
            gpuInstance,
            profileId,
            computeInstances,
            count,
        )
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstanceById(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        id: raw::c_uint,
        computeInstance: *mut nvmlComputeInstance_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpuInstanceGetComputeInstanceById
            .as_ref()
            .expect("Expected function, got error."))(gpuInstance, id, computeInstance)
    }
    pub unsafe fn nvmlComputeInstanceGetInfo_v2(
        &self,
        computeInstance: nvmlComputeInstance_t,
        info: *mut nvmlComputeInstanceInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlComputeInstanceGetInfo_v2
            .as_ref()
            .expect("Expected function, got error."))(computeInstance, info)
    }
    pub unsafe fn nvmlDeviceIsMigDeviceHandle(
        &self,
        device: nvmlDevice_t,
        isMigDevice: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceIsMigDeviceHandle
            .as_ref()
            .expect("Expected function, got error."))(device, isMigDevice)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceId(
        &self,
        device: nvmlDevice_t,
        id: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstanceId
            .as_ref()
            .expect("Expected function, got error."))(device, id)
    }
    pub unsafe fn nvmlDeviceGetComputeInstanceId(
        &self,
        device: nvmlDevice_t,
        id: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetComputeInstanceId
            .as_ref()
            .expect("Expected function, got error."))(device, id)
    }
    pub unsafe fn nvmlDeviceGetMaxMigDeviceCount(
        &self,
        device: nvmlDevice_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMaxMigDeviceCount
            .as_ref()
            .expect("Expected function, got error."))(device, count)
    }
    pub unsafe fn nvmlDeviceGetMigDeviceHandleByIndex(
        &self,
        device: nvmlDevice_t,
        index: raw::c_uint,
        migDevice: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMigDeviceHandleByIndex
            .as_ref()
            .expect("Expected function, got error."))(device, index, migDevice)
    }
    pub unsafe fn nvmlDeviceGetDeviceHandleFromMigDeviceHandle(
        &self,
        migDevice: nvmlDevice_t,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetDeviceHandleFromMigDeviceHandle
            .as_ref()
            .expect("Expected function, got error."))(migDevice, device)
    }
    pub unsafe fn nvmlGpmMetricsGet(&self, metricsGet: *mut nvmlGpmMetricsGet_t) -> nvmlReturn_t {
        (self
            .nvmlGpmMetricsGet
            .as_ref()
            .expect("Expected function, got error."))(metricsGet)
    }
    pub unsafe fn nvmlGpmSampleFree(&self, gpmSample: nvmlGpmSample_t) -> nvmlReturn_t {
        (self
            .nvmlGpmSampleFree
            .as_ref()
            .expect("Expected function, got error."))(gpmSample)
    }
    pub unsafe fn nvmlGpmSampleAlloc(&self, gpmSample: *mut nvmlGpmSample_t) -> nvmlReturn_t {
        (self
            .nvmlGpmSampleAlloc
            .as_ref()
            .expect("Expected function, got error."))(gpmSample)
    }
    pub unsafe fn nvmlGpmSampleGet(
        &self,
        device: nvmlDevice_t,
        gpmSample: nvmlGpmSample_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpmSampleGet
            .as_ref()
            .expect("Expected function, got error."))(device, gpmSample)
    }
    pub unsafe fn nvmlGpmMigSampleGet(
        &self,
        device: nvmlDevice_t,
        gpuInstanceId: raw::c_uint,
        gpmSample: nvmlGpmSample_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpmMigSampleGet
            .as_ref()
            .expect("Expected function, got error."))(device, gpuInstanceId, gpmSample)
    }
    pub unsafe fn nvmlGpmQueryDeviceSupport(
        &self,
        device: nvmlDevice_t,
        gpmSupport: *mut nvmlGpmSupport_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpmQueryDeviceSupport
            .as_ref()
            .expect("Expected function, got error."))(device, gpmSupport)
    }
    pub unsafe fn nvmlGpmQueryIfStreamingEnabled(
        &self,
        device: nvmlDevice_t,
        state: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpmQueryIfStreamingEnabled
            .as_ref()
            .expect("Expected function, got error."))(device, state)
    }
    pub unsafe fn nvmlGpmSetStreamingEnabled(
        &self,
        device: nvmlDevice_t,
        state: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlGpmSetStreamingEnabled
            .as_ref()
            .expect("Expected function, got error."))(device, state)
    }
    pub unsafe fn nvmlDeviceSetNvLinkDeviceLowPowerThreshold(
        &self,
        device: nvmlDevice_t,
        info: *mut nvmlNvLinkPowerThres_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetNvLinkDeviceLowPowerThreshold
            .as_ref()
            .expect("Expected function, got error."))(device, info)
    }
    pub unsafe fn nvmlSystemSetNvlinkBwMode(&self, nvlinkBwMode: raw::c_uint) -> nvmlReturn_t {
        (self
            .nvmlSystemSetNvlinkBwMode
            .as_ref()
            .expect("Expected function, got error."))(nvlinkBwMode)
    }
    pub unsafe fn nvmlSystemGetNvlinkBwMode(&self, nvlinkBwMode: *mut raw::c_uint) -> nvmlReturn_t {
        (self
            .nvmlSystemGetNvlinkBwMode
            .as_ref()
            .expect("Expected function, got error."))(nvlinkBwMode)
    }
    pub unsafe fn nvmlDeviceSetPowerManagementLimit_v2(
        &self,
        device: nvmlDevice_t,
        powerValue: *mut nvmlPowerValue_v2_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceSetPowerManagementLimit_v2
            .as_ref()
            .expect("Expected function, got error."))(device, powerValue)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlInit(&self) -> nvmlReturn_t {
        (self
            .nvmlInit
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetCount(&self, deviceCount: *mut raw::c_uint) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetCount
            .as_ref()
            .expect("Expected function, got error."))(deviceCount)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetHandleByIndex(
        &self,
        index: raw::c_uint,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHandleByIndex
            .as_ref()
            .expect("Expected function, got error."))(index, device)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetHandleByPciBusId(
        &self,
        pciBusId: *const raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetHandleByPciBusId
            .as_ref()
            .expect("Expected function, got error."))(pciBusId, device)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetPciInfo(
        &self,
        device: nvmlDevice_t,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPciInfo
            .as_ref()
            .expect("Expected function, got error."))(device, pci)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetPciInfo_v2(
        &self,
        device: nvmlDevice_t,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetPciInfo_v2
            .as_ref()
            .expect("Expected function, got error."))(device, pci)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetNvLinkRemotePciInfo(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetNvLinkRemotePciInfo
            .as_ref()
            .expect("Expected function, got error."))(device, link, pci)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetGridLicensableFeatures(
        &self,
        device: nvmlDevice_t,
        pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGridLicensableFeatures
            .as_ref()
            .expect("Expected function, got error."))(device, pGridLicensableFeatures)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetGridLicensableFeatures_v2(
        &self,
        device: nvmlDevice_t,
        pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGridLicensableFeatures_v2
            .as_ref()
            .expect("Expected function, got error."))(device, pGridLicensableFeatures)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetGridLicensableFeatures_v3(
        &self,
        device: nvmlDevice_t,
        pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGridLicensableFeatures_v3
            .as_ref()
            .expect("Expected function, got error."))(device, pGridLicensableFeatures)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceRemoveGpu(&self, pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t {
        (self
            .nvmlDeviceRemoveGpu
            .as_ref()
            .expect("Expected function, got error."))(pciInfo)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlEventSetWait(
        &self,
        set: nvmlEventSet_t,
        data: *mut nvmlEventData_t,
        timeoutms: raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlEventSetWait
            .as_ref()
            .expect("Expected function, got error."))(set, data, timeoutms)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetAttributes(
        &self,
        device: nvmlDevice_t,
        attributes: *mut nvmlDeviceAttributes_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetAttributes
            .as_ref()
            .expect("Expected function, got error."))(device, attributes)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlComputeInstanceGetInfo(
        &self,
        computeInstance: nvmlComputeInstance_t,
        info: *mut nvmlComputeInstanceInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlComputeInstanceGetInfo
            .as_ref()
            .expect("Expected function, got error."))(computeInstance, info)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetComputeRunningProcesses(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_v1_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetComputeRunningProcesses
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetComputeRunningProcesses_v2(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_v2_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetComputeRunningProcesses_v2
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetGraphicsRunningProcesses(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_v1_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGraphicsRunningProcesses
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetGraphicsRunningProcesses_v2(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_v2_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGraphicsRunningProcesses_v2
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetMPSComputeRunningProcesses(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_v1_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMPSComputeRunningProcesses
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetMPSComputeRunningProcesses_v2(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_v2_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetMPSComputeRunningProcesses_v2
            .as_ref()
            .expect("Expected function, got error."))(device, infoCount, infos)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlDeviceGetGpuInstancePossiblePlacements(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        placements: *mut nvmlGpuInstancePlacement_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        (self
            .nvmlDeviceGetGpuInstancePossiblePlacements
            .as_ref()
            .expect("Expected function, got error."))(device, profileId, placements, count)
    }
    #[cfg(feature = "legacy-functions")]
    pub unsafe fn nvmlVgpuInstanceGetLicenseInfo(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        licenseInfo: *mut nvmlVgpuLicenseInfo_t,
    ) -> nvmlReturn_t {
        (self
            .nvmlVgpuInstanceGetLicenseInfo
            .as_ref()
            .expect("Expected function, got error."))(vgpuInstance, licenseInfo)
    }
}
