// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package stream

import (
	"crypto/tls"
	"github.com/google/wire"
	"github.com/wandb/wandb/core/internal/api"
	"github.com/wandb/wandb/core/internal/featurechecker"
	"github.com/wandb/wandb/core/internal/filestream"
	"github.com/wandb/wandb/core/internal/filetransfer"
	"github.com/wandb/wandb/core/internal/mailbox"
	"github.com/wandb/wandb/core/internal/monitor"
	"github.com/wandb/wandb/core/internal/observability"
	"github.com/wandb/wandb/core/internal/runfiles"
	"github.com/wandb/wandb/core/internal/runhandle"
	"github.com/wandb/wandb/core/internal/sentry_ext"
	"github.com/wandb/wandb/core/internal/settings"
	"github.com/wandb/wandb/core/internal/sharedmode"
	"github.com/wandb/wandb/core/internal/tensorboard"
	"github.com/wandb/wandb/core/internal/watcher"
	"github.com/wandb/wandb/core/internal/wboperation"
	"log/slog"
	"net/http"
	"time"
)

// Injectors from apistreaminject.go:

// InjectApiStream returns a new ApiStream as a Stream interface.
func InjectApiStream(streamID ApiStreamID, debugCorePath DebugCorePath, logLevel slog.Level, sentry *sentry_ext.Client, settings2 *settings.Settings) Streamer {
	string2 := provideApiStreamIDAsString(streamID)
	streamStreamLoggerFile := openStreamLoggerFile(settings2)
	coreLogger := streamLogger(streamStreamLoggerFile, settings2, sentry, logLevel)
	apiStream := NewApiStream(string2, settings2, coreLogger)
	return apiStream
}

// Injectors from streaminject.go:

// InjectStream returns a new Stream.
func InjectStream(commit GitCommitHash, gpuResourceManager *monitor.GPUResourceManager, debugCorePath DebugCorePath, logLevel slog.Level, sentry *sentry_ext.Client, settings2 *settings.Settings) Streamer {
	clientID := sharedmode.RandomClientID()
	streamStreamLoggerFile := openStreamLoggerFile(settings2)
	coreLogger := streamLogger(streamStreamLoggerFile, settings2, sentry, logLevel)
	backend := NewBackend(coreLogger, settings2)
	peeker := &observability.Peeker{}
	client := NewGraphQLClient(backend, settings2, peeker, clientID)
	serverFeaturesCache := featurechecker.NewServerFeaturesCache(client, coreLogger)
	flowControlFactory := &FlowControlFactory{
		Logger: coreLogger,
	}
	fileTransferStats := filetransfer.NewFileTransferStats()
	mailboxMailbox := mailbox.New()
	wandbOperations := wboperation.NewOperations()
	runHandle := runhandle.New()
	systemMonitorFactory := &monitor.SystemMonitorFactory{
		Logger:             coreLogger,
		RunHandle:          runHandle,
		Settings:           settings2,
		GpuResourceManager: gpuResourceManager,
		GraphqlClient:      client,
		WriterID:           clientID,
	}
	printer := observability.NewPrinter()
	handlerFactory := &HandlerFactory{
		Commit:               commit,
		FileTransferStats:    fileTransferStats,
		Logger:               coreLogger,
		Mailbox:              mailboxMailbox,
		Operations:           wandbOperations,
		Settings:             settings2,
		SystemMonitorFactory: systemMonitorFactory,
		TerminalPrinter:      printer,
	}
	recordParserFactory := &RecordParserFactory{
		FeatureProvider:    serverFeaturesCache,
		GraphqlClientOrNil: client,
		Logger:             coreLogger,
		Operations:         wandbOperations,
		RunHandle:          runHandle,
		ClientID:           clientID,
		Settings:           settings2,
	}
	fileStreamFactory := &filestream.FileStreamFactory{
		Logger:     coreLogger,
		Operations: wandbOperations,
		Printer:    printer,
		Settings:   settings2,
	}
	fileTransferManager := NewFileTransferManager(fileTransferStats, coreLogger, settings2)
	watcher := provideFileWatcher(coreLogger)
	uploaderFactory := &runfiles.UploaderFactory{
		FileTransfer: fileTransferManager,
		FileWatcher:  watcher,
		GraphQL:      client,
		Logger:       coreLogger,
		Operations:   wandbOperations,
		RunHandle:    runHandle,
		Settings:     settings2,
	}
	senderFactory := &SenderFactory{
		ClientID:                clientID,
		Logger:                  coreLogger,
		Operations:              wandbOperations,
		Settings:                settings2,
		Backend:                 backend,
		FeatureProvider:         serverFeaturesCache,
		FileStreamFactory:       fileStreamFactory,
		FileTransferManager:     fileTransferManager,
		FileTransferStats:       fileTransferStats,
		FileWatcher:             watcher,
		RunfilesUploaderFactory: uploaderFactory,
		GraphqlClient:           client,
		Peeker:                  peeker,
		RunHandle:               runHandle,
		Mailbox:                 mailboxMailbox,
	}
	tbHandlerFactory := &tensorboard.TBHandlerFactory{
		Logger:   coreLogger,
		Settings: settings2,
	}
	writerFactory := &WriterFactory{
		Logger:   coreLogger,
		Settings: settings2,
	}
	runStream := NewRunStream(clientID, debugCorePath, serverFeaturesCache, flowControlFactory, client, handlerFactory, streamStreamLoggerFile, coreLogger, wandbOperations, recordParserFactory, senderFactory, sentry, settings2, runHandle, tbHandlerFactory, writerFactory)
	return runStream
}

// apistreaminject.go:

// ApiStreamID is a type alias for the stream ID used by ApiStream.
type ApiStreamID string

var apiStreamProviders = wire.NewSet(
	NewApiStream, wire.Bind(new(Streamer), new(*ApiStream)), wire.Bind(new(api.Peeker), new(*observability.Peeker)), wire.Struct(new(observability.Peeker)), NewBackend,
	NewGraphQLClient,
	provideApiStreamIDAsString,
	provideHttpClient, sharedmode.RandomClientID, streamLoggerProviders,
	RecordParserProviders,
)

// provideApiStreamIDAsString converts ApiStreamID to string for NewApiStream.
func provideApiStreamIDAsString(id ApiStreamID) string {
	return string(id)
}

// provideHttpClient creates an HTTP client configured with settings for
// timeout, proxy, SSL/TLS, and extra headers.
func provideHttpClient(settings2 *settings.Settings) *http.Client {

	transport := &http.Transport{
		Proxy: ProxyFn(settings2.GetHTTPProxy(), settings2.GetHTTPSProxy()),
	}

	if settings2.IsInsecureDisableSSL() {
		transport.TLSClientConfig = &tls.Config{
			InsecureSkipVerify: true,
		}
	}

	extraHeaders := settings2.GetExtraHTTPHeaders()
	if proxyAuth, ok := extraHeaders["Proxy-Authorization"]; ok {
		transport.ProxyConnectHeader = http.Header{
			"Proxy-Authorization": []string{proxyAuth},
		}
	}

	timeout := 30 * time.Second
	if graphqlTimeout := settings2.GetGraphQLTimeout(); graphqlTimeout > 0 {
		timeout = graphqlTimeout
	}

	return &http.Client{
		Transport: transport,
		Timeout:   timeout,
	}
}

// streaminject.go:

var streamProviders = wire.NewSet(
	NewRunStream, wire.Bind(new(Streamer), new(*RunStream)), wire.Bind(new(api.Peeker), new(*observability.Peeker)), wire.Struct(new(observability.Peeker)), featurechecker.NewServerFeaturesCache, filestream.FileStreamProviders, filetransfer.NewFileTransferStats, flowControlProviders,
	handlerProviders, mailbox.New, monitor.SystemMonitorProviders, NewBackend,
	NewFileTransferManager,
	NewGraphQLClient, observability.NewPrinter, provideFileWatcher,
	RecordParserProviders, runfiles.UploaderProviders, runhandle.New, SenderProviders, sharedmode.RandomClientID, streamLoggerProviders, tensorboard.TBHandlerProviders, wboperation.NewOperations, WriterProviders,
)

func provideFileWatcher(logger *observability.CoreLogger) watcher.Watcher {
	return watcher.New(watcher.Params{Logger: logger})
}
