import getpass
import logging
import os
import posixpath
import re
import shutil
import subprocess
import sys
import tempfile
from typing import Any, Dict, List, Sequence, Union

from docker.models.resource import Model  # type: ignore
from dockerpycreds.utils import find_executable  # type: ignore
from six.moves import shlex_quote
import wandb
from wandb.apis.internal import Api
from wandb.errors import ExecutionException, LaunchException

from . import _project_spec
from .utils import _is_wandb_dev_uri, _is_wandb_local_uri
from ..lib.git import GitRepo

_logger = logging.getLogger(__name__)

_GENERATED_DOCKERFILE_NAME = "Dockerfile.wandb-autogenerated"
_PROJECT_TAR_ARCHIVE_NAME = "wandb-project-docker-build-context"


def validate_docker_installation() -> None:
    """
    Verify if Docker is installed on host machine.
    """
    if not find_executable("docker"):
        raise ExecutionException(
            "Could not find Docker executable. "
            "Ensure Docker is installed as per the instructions "
            "at https://docs.docker.com/install/overview/."
        )


def validate_docker_env(project: _project_spec.Project) -> None:
    """Ensure project has a docker image associated with it"""
    if not project.docker_image:
        raise ExecutionException(
            "Project with docker environment must specify the docker image "
            "to use via 'docker_image' field."
        )


def generate_docker_image(project: _project_spec.Project, entry_cmd: str) -> str:
    """
    Uses project and entry point to generate the docker image
    """
    path = project.project_dir
    # this check will always pass since the dir attribute will always be populated
    # by _fetch_project_local
    assert isinstance(path, str)
    cmd: Sequence[str] = [
        "jupyter-repo2docker",
        "--no-run",
        "--user-id={}".format(project.docker_user_id),
        path,
        '"{}"'.format(entry_cmd),
    ]

    _logger.info(
        "Generating docker image from git repo or finding image if it already exists.........."
    )
    wandb.termlog("Generating docker image, this may take a few minutes")
    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stderr = ""
    # this will always pass, repo2docker writes to stderr.
    assert process.stderr
    for line in process.stderr:
        decoded_line = line.decode("utf-8")
        if decoded_line.endswith("\n"):
            decoded_line = decoded_line.rstrip("\n")
        print(decoded_line)  # don't spam termlog with all this
        stderr = stderr + decoded_line
    process.wait()
    image_id: List[str] = re.findall(r"Successfully tagged (.+):latest", stderr)
    if not image_id:
        image_id = re.findall(r"Reusing existing image \((.+)\)", stderr)
    if not image_id:
        raise LaunchException("error running repo2docker: {}".format(stderr))
    return image_id[0]


def pull_docker_image(docker_image: str) -> None:
    """Pulls the requested docker image"""
    import docker  # type: ignore

    info = docker_image.split(":")
    client = docker.from_env()
    try:
        if len(info) == 1:
            client.images.pull(info[0])
        else:
            client.images.pull(info[0], tag=info[1])
    except docker.errors.APIError as e:
        raise LaunchException("Docker server returned error: {}".format(e))


def build_docker_image(
    project: _project_spec.Project, base_image: str, api: Api, copy_code: bool
) -> Union[Model, Any]:
    """
    Build a docker image containing the project in `work_dir`, using the base image.
    :param project: Project class instance
    :param base_image: base_image to build the docker image off of
    :param api: instance of wandb.apis.internal Api
    :param copy_code: boolean indicating if code should be copied into the docker container
    """
    import docker

    if _is_wandb_local_uri(api.settings("base_url")) and sys.platform == "darwin":
        _, _, port = _, _, port = api.settings("base_url").split(":")
        base_url = "http://host.docker.internal:{}".format(port)
    elif _is_wandb_dev_uri(api.settings("base_url")):
        base_url = "http://host.docker.internal:9002"
    else:
        base_url = api.settings("base_url")
    image_uri = _get_docker_image_uri(name=project.name, work_dir=project.project_dir)
    copy_code_line = ""
    workdir_line = ""
    if copy_code:
        workdir = os.path.join("/home/", getpass.getuser())
        copy_code_line = "COPY {}/ {}\n".format(_PROJECT_TAR_ARCHIVE_NAME, workdir)
        workdir_line = "WORKDIR {}\n".format(workdir)
    wandb_project = project.target_project
    wandb_entity = project.target_entity
    dockerfile = (
        "FROM {imagename}\n"
        "{copy_code_line}"
        "{workdir_line}"
        "ENV WANDB_BASE_URL={base_url}\n"
        "ENV WANDB_API_KEY={api_key}\n"
        "ENV WANDB_PROJECT={wandb_project}\n"
        "ENV WANDB_ENTITY={wandb_entity}\n"
        "ENV WANDB_NAME={wandb_name}\n"
        "ENV WANDB_LAUNCH=True\n"
        "ENV WANDB_LAUNCH_CONFIG_PATH={config_path}\n"
        "ENV WANDB_RUN_ID={run_id}\n"
    ).format(
        imagename=base_image,
        copy_code_line=copy_code_line,
        workdir_line=workdir_line,
        base_url=base_url,
        api_key=api.api_key,
        wandb_project=wandb_project,
        wandb_entity=wandb_entity,
        wandb_name=project.name,
        config_path=project.config_path,
        run_id=project.run_id or None,
    )
    build_ctx_path = _create_docker_build_ctx(project.project_dir, dockerfile)
    with open(build_ctx_path, "rb") as docker_build_ctx:
        _logger.info("=== Building docker image %s ===", image_uri)
        #  TODO: replace with shelling out
        dockerfile = posixpath.join(
            _PROJECT_TAR_ARCHIVE_NAME, _GENERATED_DOCKERFILE_NAME
        )
        # TODO: remove the dependency on docker / potentially just do the append builder
        # found at: https://github.com/google/containerregistry/blob/master/client/v2_2/append_.py
        client = docker.from_env()
        try:
            image, _ = client.images.build(
                tag=image_uri,
                forcerm=True,
                dockerfile=dockerfile,
                fileobj=docker_build_ctx,
                custom_context=True,
                encoding="gzip",
            )
        except ConnectionError as e:
            raise LaunchException(
                "Error communicating with docker client: {}".format(e)
            )

    try:
        os.remove(build_ctx_path)
    except Exception:
        _logger.info(
            "Temporary docker context file %s was not deleted.", build_ctx_path
        )
    return image


def get_docker_command(
    image: Union[Model, Any], docker_args: Dict[str, Any] = None
) -> List[str]:
    """
    Constructs the docker command using the image and docker args.
    :param image: Docker image to be run
    :docker_args: dictionary of additional docker args for the command
    """
    docker_path = "docker"
    cmd: List[Any] = [docker_path, "run", "--rm"]

    if docker_args:
        for name, value in docker_args.items():
            # Passed just the name as boolean flag
            if isinstance(value, bool) and value:
                if len(name) == 1:
                    cmd += ["-" + name]
                else:
                    cmd += ["--" + name]
            else:
                # Passed name=value
                if len(name) == 1:
                    cmd += ["-" + name, value]
                else:
                    cmd += ["--" + name, value]

    cmd += [image.tags[0]]
    return [shlex_quote(c) for c in cmd]


def _get_docker_image_uri(name: str, work_dir: str) -> str:
    """
    Returns an appropriate Docker image URI for a project based on the git hash of the specified
    working directory.
    :param name: The URI of the Docker repository with which to tag the image. The
                           repository URI is used as the prefix of the image URI.
    :param work_dir: Path to the working directory in which to search for a git commit hash
    """
    name = name.replace(" ", "-") if name else "docker-project"
    # Optionally include first 7 digits of git SHA in tag name, if available.

    git_commit = GitRepo(work_dir).last_commit
    version_string = ":" + str(git_commit[:7]) if git_commit else ""
    return name + version_string


def _create_docker_build_ctx(work_dir: str, dockerfile_contents: str) -> str:
    """
    Creates build context tarfile containing Dockerfile and project code, returning path to tarfile
    """
    directory = tempfile.mkdtemp()
    try:
        dst_path = os.path.join(directory, "wandb-project-contents")
        shutil.copytree(src=work_dir, dst=dst_path)
        with open(os.path.join(dst_path, _GENERATED_DOCKERFILE_NAME), "w") as handle:
            handle.write(dockerfile_contents)
        _, result_path = tempfile.mkstemp()
        wandb.util.make_tarfile(
            output_filename=result_path,
            source_dir=dst_path,
            archive_name=_PROJECT_TAR_ARCHIVE_NAME,
        )
    finally:
        shutil.rmtree(directory)
    return result_path
