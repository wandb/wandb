# Generated by ariadne-codegen

"""This module defines base classes for generated types, including partial support for compatibility with Pydantic v1."""

from __future__ import annotations

from contextlib import suppress
from importlib.metadata import version
from typing import TYPE_CHECKING, Any, Literal, TypeVar

import pydantic
from pydantic import BaseModel, ConfigDict, Field
from pydantic import main as pydantic_main
from typing_extensions import Annotated, override

if TYPE_CHECKING:
    from pydantic.main import IncEx

pydantic_major_version, *_ = version(pydantic.__name__).split(".")
IS_PYDANTIC_V2: bool = int(pydantic_major_version) >= 2

# Maps {v2 -> v1} model config keys that were renamed in v2.
# See: https://docs.pydantic.dev/latest/migration/#changes-to-config
_V1_CONFIG_KEYS = {
    "populate_by_name": "allow_population_by_field_name",
    "str_to_lower": "anystr_lower",
    "str_strip_whitespace": "anystr_strip_whitespace",
    "str_to_upper": "anystr_upper",
    "ignored_types": "keep_untouched",
    "str_max_length": "max_anystr_length",
    "str_min_length": "min_anystr_length",
    "from_attributes": "orm_mode",
    "json_schema_extra": "schema_extra",
    "validate_default": "validate_all",
}


def _convert_v2_config(v2_config: dict[str, Any]) -> dict[str, Any]:
    """Return a copy of the v2 ConfigDict with renamed v1 keys."""
    return {_V1_CONFIG_KEYS.get(k, k): v for k, v in v2_config.items()}


if IS_PYDANTIC_V2:
    PydanticModelMetaclass = type  # placeholder
else:
    PydanticModelMetaclass = pydantic_main.ModelMetaclass


class _V1MixinMetaclass(PydanticModelMetaclass):
    def __new__(
        cls,
        name: str,
        bases: tuple[type, ...],
        namespace: dict[str, Any],
        **kwargs: Any,
    ):
        # Converts a model config in a v2 class definition, e.g.:
        #
        #     class MyModel(BaseModel):
        #         model_config = ConfigDict(populate_by_name=True)
        #
        # ...to a Config class in a v1 class definition, e.g.:
        #
        #     class MyModel(BaseModel):
        #         class Config:
        #             populate_by_name = True
        #
        if config_dict := namespace.pop("model_config", None):
            namespace["Config"] = type("Config", (), _convert_v2_config(config_dict))
        return super().__new__(cls, name, bases, namespace, **kwargs)


class PydanticV1Mixin(metaclass=_V1MixinMetaclass):
    @classmethod
    def __try_update_forward_refs__(cls, **localns: Any) -> None:
        with suppress(AttributeError):
            super().__try_update_forward_refs__(**localns)

    @classmethod
    def model_rebuild(cls, *args: Any, **kwargs: Any) -> None:
        return cls.update_forward_refs(*args, **kwargs)

    @classmethod
    def model_construct(cls, *args: Any, **kwargs: Any) -> Any:
        return cls.construct(*args, **kwargs)

    @classmethod
    def model_validate(cls, *args: Any, **kwargs: Any) -> Any:
        return cls.parse_obj(*args, **kwargs)

    @classmethod
    def model_validate_json(cls, *args: Any, **kwargs: Any) -> Any:
        return cls.parse_raw(*args, **kwargs)

    def model_dump(self, *args: Any, **kwargs: Any) -> Any:
        return self.dict(*args, **kwargs)

    def model_dump_json(self, *args: Any, **kwargs: Any) -> Any:
        return self.json(*args, **kwargs)

    def model_copy(self, *args: Any, **kwargs: Any) -> Any:
        return self.copy(*args, **kwargs)


class PydanticV2Mixin:
    # Placeholder: Pydantic v2 is already compatible with itself, so no need for extra mixins.
    pass


# Pick the mixin type based on the detected Pydantic version.
PydanticCompatMixin = PydanticV2Mixin if IS_PYDANTIC_V2 else PydanticV1Mixin


# Base class for all generated classes/types.
# This is deliberately not a docstring to prevent inclusion in generated docs.
class Base(BaseModel, PydanticCompatMixin):
    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        validate_default=True,
        extra="forbid",
        use_attribute_docstrings=True,
        from_attributes=True,
        revalidate_instances="always",
    )

    @override
    def model_dump(
        self,
        *,
        mode: Literal["json", "python"] | str = "json",  # NOTE: changed default
        include: IncEx | None = None,
        exclude: IncEx | None = None,
        context: dict[str, Any] | None = None,
        by_alias: bool = True,  # NOTE: changed default
        exclude_unset: bool = False,
        exclude_defaults: bool = False,
        exclude_none: bool = False,
        round_trip: bool = True,  # NOTE: changed default
        warnings: bool | Literal["none", "warn", "error"] = True,
        serialize_as_any: bool = False,
    ) -> dict[str, Any]:
        return super().model_dump(
            mode=mode,
            include=include,
            exclude=exclude,
            context=context,
            by_alias=by_alias,
            exclude_unset=exclude_unset,
            exclude_defaults=exclude_defaults,
            exclude_none=exclude_none,
            round_trip=round_trip,
            warnings=warnings,
            serialize_as_any=serialize_as_any,
        )

    @override
    def model_dump_json(
        self,
        *,
        indent: int | None = None,
        include: IncEx | None = None,
        exclude: IncEx | None = None,
        context: dict[str, Any] | None = None,
        by_alias: bool = True,  # NOTE: changed default
        exclude_unset: bool = False,
        exclude_defaults: bool = False,
        exclude_none: bool = False,
        round_trip: bool = True,  # NOTE: changed default
        warnings: bool | Literal["none", "warn", "error"] = True,
        serialize_as_any: bool = False,
    ) -> str:
        return super().model_dump_json(
            indent=indent,
            include=include,
            exclude=exclude,
            context=context,
            by_alias=by_alias,
            exclude_unset=exclude_unset,
            exclude_defaults=exclude_defaults,
            exclude_none=exclude_none,
            round_trip=round_trip,
            warnings=warnings,
            serialize_as_any=serialize_as_any,
        )


# Base class with extra customization for GQL generated types.
# This is deliberately not a docstring to prevent inclusion in generated docs.
class GQLBase(Base):
    model_config = ConfigDict(
        extra="ignore",
        protected_namespaces=(),
    )


# ------------------------------------------------------------------------------
# Reusable annotations for field types
T = TypeVar("T")

GQLId = Annotated[
    str,
    Field(repr=False, strict=True, frozen=True),
]

Typename = Annotated[
    T,
    Field(repr=False, alias="__typename", frozen=True),
]


# FIXME: Restore or modify this after ensuring pydantic v1 compatibility.
# def validate_maybe_json(v: Any, handler: ValidatorFunctionWrapHandler) -> Any:
#     """Wraps default Json[...] field validator to allow instantiation with an already-decoded value."""
#     try:
#         return handler(v)
#     except ValidationError:
#         # Try revalidating after properly jsonifying the value
#         return handler(to_json(v, by_alias=True, round_trip=True))


# SerializedToJson = Annotated[
#     Json[T],
#     # Allow lenient instantiation/validation: incoming data may already be deserialized.
#     WrapValidator(validate_maybe_json),
# ]
