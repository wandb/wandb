# A fragment on ArtifactCollection that only includes minimal identifying fields.
fragment CollectionInfoFragment on ArtifactCollection {
  __typename
  name
  project {
    ...ProjectInfoFragment
  }
}

# A fragment on ArtifactSequence that only includes minimal identifying fields.
fragment SourceCollectionInfoFragment on ArtifactSequence {
  __typename
  name
  project {
    ...ProjectInfoFragment
  }
}

# A fragment on Project that only includes minimal identifying fields.
fragment ProjectInfoFragment on Project {
  name
  entity {
    name
  }
}

# Base artifact fragment that excludes the `aliases` field.  Necessary for compatibility with both:
# - the pre-existing `ArtifactFragment` fragment
# - the `RegistryVersionsPage` fragment, which omits `Artifact.aliases` but includes `ArtifactCollectionMembership.aliases`
fragment ArtifactFragmentWithoutAliases on Artifact {
  id
  artifactSequence {
    ...SourceCollectionInfoFragment
  }
  versionIndex
  artifactType {
    name
  }
  description
  metadata
  ttlDurationSeconds @include(if: true) # Workaround: ensures generated pydantic field defaults to `None`
  ttlIsInherited @include(if: true) # Workaround: ensures generated pydantic field defaults to `None`
  tags @include(if: true) {
    # Workaround: ensures generated pydantic field defaults to `None`
    ...TagFragment
  }
  historyStep @include(if: true) # Workaround: ensures generated pydantic field defaults to `None`
  state
  size
  digest
  commitHash
  fileCount
  createdAt
  updatedAt
}

fragment ArtifactFragment on Artifact {
  ...ArtifactFragmentWithoutAliases
  aliases @include(if: true) {
    # Workaround: ensures generated pydantic field defaults to `None`
    artifactCollection {
      ...CollectionInfoFragment
    }
    ...ArtifactAliasFragment
  }
}

# An ArtifactManifest with a download URL to fetch the full manifest contents.
fragment DeferredManifestFragment on ArtifactManifest {
  file {
    directUrl
  }
}

fragment ArtifactMembershipFragment on ArtifactCollectionMembership {
  __typename
  id
  versionIndex
  aliases {
    ...ArtifactAliasFragment
  }
  artifactCollection {
    ...CollectionInfoFragment
  }
  artifact {
    ...ArtifactFragment
  }
}

fragment VersionedArtifactConnectionFragment on VersionedArtifactConnection {
  totalCount
  pageInfo {
    ...PageInfoFragment
  }
  edges {
    node {
      ...ArtifactFragment
    }
    version
  }
}

query ProjectArtifacts(
  $project: String!
  $entity: String!
  $type: String!
  $collection: String!
  $cursor: String
  $perPage: Int = 50
  $order: String
  $filters: JSONString
) {
  project(name: $project, entityName: $entity) {
    artifactType(name: $type) {
      # NOTE: The node being aliased is named:
      # - `artifactCollection` for new servers
      # - `artifactSequence` for old servers
      artifactCollection: artifactCollection(name: $collection) {
        artifacts(filters: $filters, after: $cursor, first: $perPage, order: $order) {
          ...VersionedArtifactConnectionFragment
        }
      }
    }
  }
}

fragment RunOutputArtifactConnectionFragment on ArtifactConnection {
  totalCount
  pageInfo {
    ...PageInfoFragment
  }
  edges {
    node {
      ...ArtifactFragment
    }
  }
}

fragment RunInputArtifactConnectionFragment on InputArtifactConnection {
  totalCount
  pageInfo {
    ...PageInfoFragment
  }
  edges {
    node {
      ...ArtifactFragment
    }
  }
}

query RunOutputArtifacts(
  $entity: String!
  $project: String!
  $runName: String!
  $cursor: String
  $perPage: Int
) {
  project(name: $project, entityName: $entity) {
    run(name: $runName) {
      artifacts: outputArtifacts(after: $cursor, first: $perPage) {
        ...RunOutputArtifactConnectionFragment
      }
    }
  }
}

query RunInputArtifacts(
  $entity: String!
  $project: String!
  $runName: String!
  $cursor: String
  $perPage: Int
) {
  project(name: $project, entityName: $entity) {
    run(name: $runName) {
      artifacts: inputArtifacts(after: $cursor, first: $perPage) {
        ...RunInputArtifactConnectionFragment
      }
    }
  }
}

query FetchLinkedArtifacts($artifactID: ID!) {
  artifact(id: $artifactID) {
    artifactMemberships {
      edges {
        node {
          versionIndex
          aliases {
            ...ArtifactAliasFragment
          }
          artifactCollection {
            ...CollectionInfoFragment
          }
        }
      }
    }
  }
}

query FetchArtifactManifest($id: ID!) {
  artifact(id: $id) {
    currentManifest {
      ...DeferredManifestFragment
    }
  }
}

query ArtifactByID($id: ID!) {
  artifact(id: $id) {
    ...ArtifactFragment
  }
}

query ArtifactByName(
  $entity: String!
  $project: String!
  $name: String!
  $enableTracking: Boolean
) {
  project(name: $project, entityName: $entity) {
    artifact(name: $name, enableTracking: $enableTracking) {
      ...ArtifactFragment
    }
  }
}

query ArtifactMembershipByName($entity: String!, $project: String!, $name: String!) {
  project(name: $project, entityName: $entity) {
    artifactCollectionMembership(name: $name) {
      ...ArtifactMembershipFragment
    }
  }
}

# A fragment on Run that only includes minimal descriptive fields.
fragment RunInfoFragment on Run {
  __typename
  id
  name
  project {
    ...ProjectInfoFragment
  }
}

query ArtifactUsedBy($id: ID!) {
  artifact(id: $id) {
    usedBy {
      edges {
        node {
          ...RunInfoFragment
        }
      }
    }
  }
}

query ArtifactCreatedBy($id: ID!) {
  artifact(id: $id) {
    createdBy {
      ... on Run {
        ...RunInfoFragment
      }
    }
  }
}

query ArtifactType($entityName: String, $projectName: String, $name: String!) {
  project(name: $projectName, entityName: $entityName) {
    artifact(name: $name) {
      artifactType {
        name
      }
    }
  }
}

# ---------------------------------------------------------------------------
mutation AddAliases($input: AddAliasesInput!) {
  addAliases(input: $input) {
    success
  }
}
mutation DeleteAliases($input: DeleteAliasesInput!) {
  deleteAliases(input: $input) {
    success
  }
}

mutation UpdateArtifact($input: UpdateArtifactInput!) {
  updateArtifact(input: $input) {
    artifact {
      ...ArtifactFragment
    }
  }
}

mutation DeleteArtifact($input: DeleteArtifactInput!) {
  deleteArtifact(input: $input) {
    artifact {
      id
    }
  }
}

mutation LinkArtifact($input: LinkArtifactInput!) {
  linkArtifact(input: $input) {
    versionIndex
    artifactMembership @include(if: true) {
      # Workaround: ensures generated pydantic field defaults to `None`
      ...ArtifactMembershipFragment
    }
  }
}

mutation UnlinkArtifact($input: UnlinkArtifactInput!) {
  unlinkArtifact(input: $input) {
    success
  }
}
