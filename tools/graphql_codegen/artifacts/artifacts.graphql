# Base artifact fragment that excludes the `aliases` field.  Necessary for compatibility with both:
# - the pre-existing `ArtifactFragment` fragment
# - the `RegistryVersionsPage` fragment, which omits `Artifact.aliases` but includes `ArtifactCollectionMembership.aliases`
fragment ArtifactFragmentWithoutAliases on Artifact {
  id
  artifactSequence {
    project {
      entityName
      name
    }
    name
  }
  versionIndex
  artifactType {
    name
  }
  description
  metadata
  ttlDurationSeconds @include(if: true) # Workaround: ensures generated pydantic field defaults to `None`
  ttlIsInherited @include(if: true) # Workaround: ensures generated pydantic field defaults to `None`
  tags @include(if: true) {
    # Workaround: ensures generated pydantic field defaults to `None`
    name
  }
  historyStep @include(if: true) # Workaround: ensures generated pydantic field defaults to `None`
  state
  currentManifest {
    file {
      directUrl
    }
  }
  commitHash
  fileCount
  createdAt
  updatedAt
}

fragment ArtifactFragment on Artifact {
  ...ArtifactFragmentWithoutAliases
  aliases @include(if: true) {
    # Workaround: ensures generated pydantic field defaults to `None`
    artifactCollection {
      __typename
      project {
        entityName
        name
      }
      name
    }
    alias
  }
}

fragment MembershipWithArtifact on ArtifactCollectionMembership {
  id
  artifactCollection {
    __typename
    id
    name
    project {
      id
      entityName
      name
    }
  }
  artifact {
    ...ArtifactFragment
  }
}

fragment ArtifactsFragment on VersionedArtifactConnection {
  totalCount
  edges {
    node {
      ...ArtifactFragment
    }
    version
    cursor
  }
  pageInfo {
    endCursor
    hasNextPage
  }
}

query ProjectArtifacts(
  $project: String!
  $entity: String!
  $type: String!
  $collection: String!
  $cursor: String
  $perPage: Int = 50
  $order: String
  $filters: JSONString
) {
  project(name: $project, entityName: $entity) {
    artifactType(name: $type) {
      # NOTE: The node being aliased is named:
      # - `artifactCollection` for new servers
      # - `artifactSequence` for old servers
      artifactCollection: artifactCollection(name: $collection) {
        name
        artifacts(filters: $filters, after: $cursor, first: $perPage, order: $order) {
          ...ArtifactsFragment
        }
      }
    }
  }
}

query RunOutputArtifacts(
  $entity: String!
  $project: String!
  $runName: String!
  $cursor: String
  $perPage: Int
) {
  project(name: $project, entityName: $entity) {
    run(name: $runName) {
      outputArtifacts(after: $cursor, first: $perPage) {
        totalCount
        edges {
          node {
            ...ArtifactFragment
          }
          cursor
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }
  }
}

query RunInputArtifacts(
  $entity: String!
  $project: String!
  $runName: String!
  $cursor: String
  $perPage: Int
) {
  project(name: $project, entityName: $entity) {
    run(name: $runName) {
      inputArtifacts(after: $cursor, first: $perPage) {
        totalCount
        edges {
          node {
            ...ArtifactFragment
          }
          cursor
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }
  }
}

query FetchLinkedArtifacts($artifactID: ID!) {
  artifact(id: $artifactID) {
    artifactMemberships {
      edges {
        node {
          aliases {
            alias
          }
          versionIndex
          artifactCollection {
            project {
              entityName
              name
            }
            name
            __typename
          }
        }
      }
    }
  }
}

query FetchArtifactManifest($entityName: String!, $projectName: String!, $name: String!) {
  project(entityName: $entityName, name: $projectName) {
    artifact(name: $name) {
      currentManifest {
        file {
          directUrl
        }
      }
    }
  }
}

query ArtifactByID($id: ID!) {
  artifact(id: $id) {
    ...ArtifactFragment
  }
}

query ArtifactByName(
  $entityName: String!
  $projectName: String!
  $name: String!
  $enableTracking: Boolean
) {
  project(name: $projectName, entityName: $entityName) {
    artifact(name: $name, enableTracking: $enableTracking) {
      ...ArtifactFragment
    }
  }
}

query ArtifactViaMembershipByName($entityName: String!, $projectName: String!, $name: String!) {
  project(name: $projectName, entityName: $entityName) {
    artifactCollectionMembership(name: $name) {
      ...MembershipWithArtifact
    }
  }
}

query ArtifactUsedBy($id: ID!) {
  artifact(id: $id) {
    usedBy {
      edges {
        node {
          name
          project {
            name
            entityName
          }
        }
      }
    }
  }
}

query ArtifactCreatedBy($id: ID!) {
  artifact(id: $id) {
    createdBy {
      ... on Run {
        name
        project {
          name
          entityName
        }
      }
    }
  }
}

query ArtifactType($entityName: String, $projectName: String, $name: String!) {
  project(name: $projectName, entityName: $entityName) {
    artifact(name: $name) {
      artifactType {
        name
      }
    }
  }
}

# ---------------------------------------------------------------------------
mutation AddAliases($artifactID: ID!, $aliases: [ArtifactCollectionAliasInput!]!) {
  addAliases(input: { artifactID: $artifactID, aliases: $aliases }) {
    success
  }
}
mutation DeleteAliases($artifactID: ID!, $aliases: [ArtifactCollectionAliasInput!]!) {
  deleteAliases(input: { artifactID: $artifactID, aliases: $aliases }) {
    success
  }
}

mutation UpdateArtifact(
  $artifactID: ID!
  $description: String
  $metadata: JSONString
  $ttlDurationSeconds: Int64
  $tagsToAdd: [TagInput!]
  $tagsToDelete: [TagInput!]
  $aliases: [ArtifactAliasInput!]
) {
  updateArtifact(
    input: {
      artifactID: $artifactID
      description: $description
      metadata: $metadata
      ttlDurationSeconds: $ttlDurationSeconds
      tagsToAdd: $tagsToAdd
      tagsToDelete: $tagsToDelete
      aliases: $aliases
    }
  ) {
    artifact {
      ...ArtifactFragment
    }
  }
}

mutation DeleteArtifact($artifactID: ID!, $deleteAliases: Boolean) {
  deleteArtifact(input: { artifactID: $artifactID, deleteAliases: $deleteAliases }) {
    artifact {
      id
    }
  }
}

mutation LinkArtifact($input: LinkArtifactInput!) {
  linkArtifact(input: $input) {
    versionIndex
    artifactMembership @include(if: true) {
      # Workaround: ensures generated pydantic field defaults to `None`
      ...MembershipWithArtifact
    }
  }
}

mutation UnlinkArtifact($artifactID: ID!, $artifactPortfolioID: ID!) {
  unlinkArtifact(input: { artifactID: $artifactID, artifactPortfolioID: $artifactPortfolioID }) {
    artifactID
    success
    clientMutationId
  }
}
